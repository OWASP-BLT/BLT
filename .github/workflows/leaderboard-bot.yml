name: Leaderboard Bot

# Uses pull_request_target so it runs with base repo permissions for forked PRs.
# SECURITY: We do NOT check out or execute PR code. We only use the GitHub API.
on:
  pull_request_target:
    types:
      - opened

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  post_leaderboard:
    runs-on: ubuntu-latest
    env:
      # Coderabbit discussion encouragement (anti-abuse configurable)
      # CR_DISCUSSION_MODE: visible | hidden | separate
      CR_DISCUSSION_MODE: visible
      # Points per counted discussion (default 0 = visible only, no points unless you enable)
      CR_DISCUSSION_POINTS: '0'
      # Daily cap for counted discussions per user (UTC day)
      CR_DISCUSSION_DAILY_CAP: '7'
    steps:
      - name: Post Leaderboard Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr = context.payload.pull_request;
            const pull_number = pr.number;
            const prAuthor = pr.user.login;

            core.info(`Processing PR #${pull_number} by @${prAuthor}`);

            // Bot detection helper function
            const isBot = (user) => {
              if (!user || !user.login) return false;
              const loginLower = user.login.toLowerCase();
              const botPatterns = ['copilot', '[bot]', 'dependabot', 'github-actions', 'renovate', 'actions-user'];
              return (user.type && user.type === 'Bot') ||
                     botPatterns.some(pattern => loginLower.includes(pattern));
            };

            // Skip leaderboard for bot accounts
            if (isBot(pr.user)) {
              core.info(`Skipping leaderboard for bot account: @${prAuthor}`);
              return;
            }

            // POLICY: auto-close new PRs if author already has >= 10 open PRs
            const MAX_OPEN_PRS_PER_AUTHOR = 10;
            try {
              const searchRes = await github.rest.search.issuesAndPullRequests({
                q: `repo:${owner}/${repo} is:pr is:open author:${prAuthor}`,
                per_page: 100
              });
              const openItems = (searchRes.data && searchRes.data.items) ? searchRes.data.items : [];
              const preExistingOpenCount = openItems.filter(item => item.number !== pull_number).length;
              core.info(`Open PRs for @${prAuthor} (excluding current): ${preExistingOpenCount}`);

              if (preExistingOpenCount >= MAX_OPEN_PRS_PER_AUTHOR) {
                const msg = [
                  `Hi @${prAuthor}, thanks for your contribution!`,
                  ``,
                  `This PR is being auto-closed because you currently have ${preExistingOpenCount} open PRs in this repository (limit: ${MAX_OPEN_PRS_PER_AUTHOR}).`,
                  `Please finish or close some existing PRs before opening new ones.`,
                  ``,
                  `If you believe this was closed in error, please contact the maintainers.`
                ].join('\n');

                // Leave a comment explaining the closure
                await github.rest.issues.createComment({
                  owner, repo, issue_number: pull_number, body: msg
                });

                // Close the PR
                await github.rest.pulls.update({
                  owner, repo, pull_number, state: 'closed'
                });

                core.info(`Auto-closed PR #${pull_number} due to open PR limit.`);
                return; // stop further processing
              }
            } catch (e) {
              core.warning(`Failed to evaluate open PR limit for @${prAuthor}: ${e.message}`);
              // Continue even if limit check failed to avoid blocking regular behavior
            }

            // Get current month date range (UTC)
            const now = new Date();
            const startOfMonth = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), 1, 0, 0, 0, 0));
            const endOfMonth = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth() + 1, 0, 23, 59, 59, 999));
            const threeMonthsAgo = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth() - 3, 1));

            core.info(`Fetching stats for ${startOfMonth.toISOString()} to ${endOfMonth.toISOString()}`);

            // Config
            const MAX_PAGES = 10;
            const PER_PAGE = 100;

            const CR_MODE = (process.env.CR_DISCUSSION_MODE || 'visible').toLowerCase();
            const CR_POINTS = parseInt(process.env.CR_DISCUSSION_POINTS || '0', 10);
            const CR_DAILY_CAP = parseInt(process.env.CR_DISCUSSION_DAILY_CAP || '7', 10);

            // GraphQL: PRs updated recently (we filter to created/merged/closed in-month)
            const prQuery = `
              query($owner: String!, $repo: String!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequests(first: ${PER_PAGE}, orderBy: {field: UPDATED_AT, direction: DESC}, after: $after) {
                    nodes {
                      number
                      author { login }
                      createdAt
                      updatedAt
                      mergedAt
                      closedAt
                      merged
                      state
                    }
                    pageInfo { hasNextPage endCursor }
                  }
                }
              }
            `;

            // GraphQL: PRs with reviews (for first-two-reviews logic)
            const reviewsQuery = `
              query($owner: String!, $repo: String!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequests(first: ${PER_PAGE}, orderBy: {field: UPDATED_AT, direction: DESC}, after: $after) {
                    nodes {
                      number
                      updatedAt
                      reviews(first: 100) {
                        nodes {
                          submittedAt
                          author { login }
                        }
                      }
                    }
                    pageInfo { hasNextPage endCursor }
                  }
                }
              }
            `;

            // GraphQL: All OPEN PRs repo-wide (for +1 per open)
            const openPRsQuery = `
              query($owner: String!, $repo: String!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequests(states: OPEN, first: ${PER_PAGE}, orderBy: {field: UPDATED_AT, direction: DESC}, after: $after) {
                    nodes {
                      number
                      author { login }
                      createdAt
                      updatedAt
                    }
                    pageInfo { hasNextPage endCursor }
                  }
                }
              }
            `;

            // 1) Fetch PRs touching this month (created/merged/closed in-month)
            let allPRsThisMonth = [];
            let prHasNextPage = true;
            let prCursor = null;
            let prPageCount = 0;

            while (prHasNextPage && prPageCount < MAX_PAGES) {
              try {
                const result = await github.graphql(prQuery, { owner, repo, after: prCursor });
                const prs = result.repository.pullRequests;

                const monthPRs = prs.nodes.filter(prNode => {
                  const createdAt = new Date(prNode.createdAt);
                  const mergedAt = prNode.mergedAt ? new Date(prNode.mergedAt) : null;
                  const closedAt = prNode.closedAt ? new Date(prNode.closedAt) : null;

                  const createdThisMonth = createdAt >= startOfMonth && createdAt <= endOfMonth;
                  const mergedThisMonth = mergedAt && mergedAt >= startOfMonth && mergedAt <= endOfMonth;
                  const closedThisMonth = closedAt && closedAt >= startOfMonth && closedAt <= endOfMonth;

                  return createdThisMonth || mergedThisMonth || closedThisMonth;
                });

                allPRsThisMonth = allPRsThisMonth.concat(monthPRs);

                // Early exit if oldest updatedAt is before startOfMonth
                if (prs.nodes.length > 0) {
                  const oldestUpdatedAt = new Date(prs.nodes[prs.nodes.length - 1].updatedAt);
                  if (oldestUpdatedAt < startOfMonth) {
                    core.info(`Stopping PR pagination - reached PRs updated before ${startOfMonth.toISOString()}`);
                    prHasNextPage = false;
                  }
                }

                if (prHasNextPage) {
                  prHasNextPage = prs.pageInfo.hasNextPage;
                  prCursor = prs.pageInfo.endCursor;
                }
                prPageCount++;
              } catch (error) {
                core.warning(`Error fetching PRs: ${error.message}`);
                break;
              }
            }

            // 2) Fetch reviews and count first two reviews per PR within the month (any state)
            let firstTwoReviews = [];
            let revHasNextPage = true;
            let revCursor = null;
            let revPageCount = 0;

            while (revHasNextPage && revPageCount < MAX_PAGES) {
              try {
                const result = await github.graphql(reviewsQuery, { owner, repo, after: revCursor });
                const prs = result.repository.pullRequests;

                for (const prNode of prs.nodes) {
                  const nodes = (prNode.reviews && prNode.reviews.nodes) ? prNode.reviews.nodes.filter(r => r.submittedAt) : [];
                  // Only reviews submitted within this month; sort by time asc; take first 2
                  const inMonth = nodes
                    .filter(r => {
                      const dt = new Date(r.submittedAt);
                      return dt >= startOfMonth && dt <= endOfMonth;
                    })
                    .sort((a, b) => new Date(a.submittedAt) - new Date(b.submittedAt))
                    .slice(0, 2);

                  for (const r of inMonth) {
                    firstTwoReviews.push({
                      submitted_at: r.submittedAt,
                      user: { login: r.author ? r.author.login : null }
                    });
                  }
                }

                // Early exit: if oldest PR updatedAt is older than three months, stop paginating
                const oldestPr = prs.nodes[prs.nodes.length - 1];
                if (oldestPr) {
                  const oldestUpdatedAt = new Date(oldestPr.updatedAt);
                  if (oldestUpdatedAt < threeMonthsAgo) {
                    core.info(`Stopping reviews pagination - reached PRs updated before ${threeMonthsAgo.toISOString()}`);
                    break;
                  }
                }

                revHasNextPage = prs.pageInfo.hasNextPage;
                revCursor = prs.pageInfo.endCursor;
                revPageCount++;
              } catch (error) {
                core.warning(`Error fetching reviews: ${error.message}`);
                break;
              }
            }

            // 3) Fetch all issue comments for the month (repo-wide)
            let allComments = [];
            let commentPage = 1;
            while (commentPage <= MAX_PAGES) {
              try {
                const { data: comments } = await github.rest.issues.listCommentsForRepo({
                  owner, repo, since: startOfMonth.toISOString(), per_page: PER_PAGE, page: commentPage
                });

                if (comments.length === 0) break;

                const monthComments = comments.filter(comment => {
                  const dt = new Date(comment.created_at);
                  return dt >= startOfMonth && dt <= endOfMonth;
                });

                allComments = allComments.concat(monthComments);
                commentPage++;
              } catch (error) {
                core.warning(`Error fetching comments: ${error.message}`);
                break;
              }
            }

            // 4) Fetch all OPEN PRs (repo-wide) for +1 per open PR
            let openByUser = {};
            let openHasNext = true;
            let openCursor = null;
            let openPageCount = 0;

            while (openHasNext && openPageCount < MAX_PAGES) {
              try {
                const result = await github.graphql(openPRsQuery, { owner, repo, after: openCursor });
                const prs = result.repository.pullRequests;

                for (const n of prs.nodes) {
                  if (!n.author || !n.author.login) continue;
                  const login = n.author.login;
                  openByUser[login] = (openByUser[login] || 0) + 1;
                }

                openHasNext = prs.pageInfo.hasNextPage;
                openCursor = prs.pageInfo.endCursor;
                openPageCount++;
              } catch (error) {
                core.warning(`Error fetching open PRs: ${error.message}`);
                break;
              }
            }

            // Separate PRs by type (month-scoped for merged/closed)
            const mergedPRs = allPRsThisMonth.filter(n => {
              const dt = n.mergedAt ? new Date(n.mergedAt) : null;
              return dt && dt >= startOfMonth && dt <= endOfMonth;
            });

            const closedPRs = allPRsThisMonth.filter(n => {
              const dt = n.closedAt ? new Date(n.closedAt) : null;
              return dt && dt >= startOfMonth && dt <= endOfMonth && !n.merged;
            });

            // Aggregate per-user stats
            const userStats = {};
            const ensureUser = (login) => {
              if (!userStats[login]) {
                userStats[login] = { openPrs: 0, mergedPrs: 0, closedPrs: 0, reviews: 0, comments: 0, crChats: 0, crBonus: 0, total: 0 };
              }
            };

            // +1 per OPEN PR (repo-wide; no artificial cap)
            for (const [login, count] of Object.entries(openByUser)) {
              if (isBot({ login })) continue;
              ensureUser(login);
              userStats[login].openPrs += count;
            }

            // +10 per merged this month
            for (const node of mergedPRs) {
              if (node.author && node.author.login) {
                if (isBot({ login: node.author.login })) continue;
                ensureUser(node.author.login);
                userStats[node.author.login].mergedPrs++;
              }
            }

            // âˆ’2 per closed (not merged) this month
            for (const node of closedPRs) {
              if (node.author && node.author.login) {
                if (isBot({ login: node.author.login })) continue;
                ensureUser(node.author.login);
                userStats[node.author.login].closedPrs++;
              }
            }

            // +5 per review (first two per PR this month; any state)
            for (const r of firstTwoReviews) {
              if (r.user && r.user.login) {
                if (isBot({ login: r.user.login })) continue;
                ensureUser(r.user.login);
                userStats[r.user.login].reviews++;
              }
            }

            // +2 per repo comment this month
            for (const c of allComments) {
              if (c.user && c.user.login) {
                if (isBot({ login: c.user.login })) continue;
                ensureUser(c.user.login);
                userStats[c.user.login].comments++;
              }
            }

            // Coderabbit discussions (visible/hidden/separate)
            const isCRPing = (body) => {
              if (!body) return false;
              const b = String(body).toLowerCase();
              return b.includes('coderabbit') || b.includes('@coderabbitai');
            };

            // Track per user per UTC day
            const crCountsByUserByDay = {};
            const crTotalByUser = {};
            for (const c of allComments) {
              const login = c.user && c.user.login ? c.user.login : null;
              if (!login || isBot({ login })) continue;
              if (!isCRPing(c.body)) continue;
              const day = new Date(c.created_at).toISOString().slice(0, 10); // YYYY-MM-DD (UTC)
              crCountsByUserByDay[login] = crCountsByUserByDay[login] || {};
              crCountsByUserByDay[login][day] = (crCountsByUserByDay[login][day] || 0) + 1;
              crTotalByUser[login] = (crTotalByUser[login] || 0) + 1;
            }

            for (const [login, perDay] of Object.entries(crCountsByUserByDay)) {
              ensureUser(login);
              // Always show monthly total if visible/separate
              userStats[login].crChats = (userStats[login].crChats || 0) + (crTotalByUser[login] || 0);

              // Scoring
              let daySum = 0;
              for (const cnt of Object.values(perDay)) {
                daySum += Math.min(cnt, CR_DAILY_CAP);
              }
              const awarded = (CR_MODE === 'separate') ? 0 : (daySum * CR_POINTS);
              userStats[login].crBonus = (userStats[login].crBonus || 0) + awarded;
            }

            // Final scoring:
            // open: +1 each; merged: +10; closed: âˆ’2; reviews: +5; comments: +2; CR bonus per mode
            for (const login in userStats) {
              const s = userStats[login];
              s.total =
                (s.openPrs * 1) +
                (s.mergedPrs * 10) +
                (s.closedPrs * -2) +
                (s.reviews * 5) +
                (s.comments * 2) +
                (s.crBonus || 0);
            }

            // Sorting: by total, then merged PRs, then reviews, then alpha
            const sortedUsers = Object.entries(userStats)
              .map(([login, stats]) => ({ login, ...stats }))
              .sort((a, b) => {
                if (b.total !== a.total) return b.total - a.total;
                if (b.mergedPrs !== a.mergedPrs) return b.mergedPrs - a.mergedPrs;
                if (b.reviews !== a.reviews) return b.reviews - a.reviews;
                return a.login.localeCompare(b.login, 'en-US', { sensitivity: 'base' });
              });

            const authorIndex = sortedUsers.findIndex(u => u.login === prAuthor);
            const displayMonth = startOfMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric', timeZone: 'UTC' });

            // Generate leaderboard comment
            const commentMarker = '<!-- leaderboard-bot -->';
            let commentBody = commentMarker + '\n';
            commentBody += '## ðŸ“Š Monthly Leaderboard\n\n';
            commentBody += `Hi @${prAuthor}! Here's how you rank for ${displayMonth}:\n\n`;

            // Column set (CR chats column shown only if visible mode)
            const showCRCol = (CR_MODE === 'visible');
            const headerCols = ['Rank', 'User', 'Open PRs', 'PRs (merged)', 'PRs (closed)', 'Reviews', 'Comments'];
            if (showCRCol) headerCols.push('CR chats');
            headerCols.push('Total');

            commentBody += `| ${headerCols.join(' | ')} |\n`;
            commentBody += `| ${headerCols.map(() => '---').join(' | ')} |\n`;

            const rowFor = (rankLabel, u, bold = false, medal = '') => {
              const userCell = bold ? `**\`@${u.login}\`** âœ¨` : `\`@${u.login}\``;
              const cells = [
                medal ? `${medal} ${rankLabel}` : `${rankLabel}`,
                userCell,
                `${u.openPrs}`,
                `${u.mergedPrs}`,
                `${u.closedPrs}`,
                `${u.reviews}`,
                `${u.comments}`
              ];
              if (showCRCol) cells.push(`${u.crChats || 0}`);
              cells.push(`**${u.total}**`);
              return `| ${cells.join(' | ')} |`;
            };

            if (authorInd