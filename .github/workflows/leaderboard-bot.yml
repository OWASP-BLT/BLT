name: Leaderboard Bot

# Uses pull_request_target so it runs with base repo permissions for forked PRs.
# SECURITY: We do NOT check out or execute PR code. We only use the GitHub API.
on:
  pull_request_target:
    types:
      - opened

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  post_leaderboard:
    runs-on: ubuntu-latest
    steps:
      - name: Post Leaderboard Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr = context.payload.pull_request;
            const pull_number = pr.number;
            const prAuthor = pr.user.login;

            core.info(`Processing PR #${pull_number} by @${prAuthor}`);

            // Bot detection helper function
            const isBot = (user) => {
              if (!user || !user.login) return false;
              const loginLower = user.login.toLowerCase();
              const botPatterns = ['copilot', '[bot]', 'dependabot', 'github-actions', 'renovate'];
              return (user.type && user.type === 'Bot') ||
                     botPatterns.some(pattern => loginLower.includes(pattern));
            };

            // Skip leaderboard for bot accounts
            if (isBot(pr.user)) {
              core.info(`Skipping leaderboard for bot account: @${prAuthor}`);
              return;
            }

            // POLICY: auto-close new PRs if author already has >= 10 open PRs
            const MAX_OPEN_PRS_PER_AUTHOR = 10;
            try {
              const searchRes = await github.rest.search.issuesAndPullRequests({
                q: `repo:${owner}/${repo} is:pr is:open author:${prAuthor}`,
                per_page: 100
              });
              const openItems = (searchRes.data && searchRes.data.items) ? searchRes.data.items : [];
              const preExistingOpenCount = openItems.filter(item => item.number !== pull_number).length;
              core.info(`Open PRs for @${prAuthor} (excluding current): ${preExistingOpenCount}`);

              if (preExistingOpenCount >= MAX_OPEN_PRS_PER_AUTHOR) {
                const msg = [
                  `Hi @${prAuthor}, thanks for your contribution!`,
                  ``,
                  `This PR is being auto-closed because you currently have ${preExistingOpenCount} open PRs in this repository (limit: ${MAX_OPEN_PRS_PER_AUTHOR}).`,
                  `Please finish or close some existing PRs before opening new ones.`,
                  ``,
                  `If you believe this was closed in error, please contact the maintainers.`
                ].join('\n');

                // Leave a comment explaining the closure
                await github.rest.issues.createComment({
                  owner, repo, issue_number: pull_number, body: msg
                });

                // Close the PR
                await github.rest.pulls.update({
                  owner, repo, pull_number, state: 'closed'
                });

                core.info(`Auto-closed PR #${pull_number} due to open PR limit.`);
                return; // stop further processing
              }
            } catch (e) {
              core.warning(`Failed to evaluate open PR limit for @${prAuthor}: ${e.message}`);
              // Continue even if limit check failed to avoid blocking regular behavior
            }

            // Get current month date range (UTC)
            const now = new Date();
            const startOfMonth = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), 1, 0, 0, 0, 0));
            const endOfMonth = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth() + 1, 0, 23, 59, 59, 999));
            const threeMonthsAgo = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth() - 3, 1));

            core.info(`Fetching stats for ${startOfMonth.toISOString()} to ${endOfMonth.toISOString()}`);

            // Configuration constants
            const MAX_PAGES = 10;
            const PER_PAGE = 100;
            const MAX_TOTAL_PRS_FOR_SCORING = 5;  // cap Total PRs counted toward score

            // GraphQL query to fetch all PRs updated recently (we filter to created/merged/closed in-month)
            const prQuery = `
              query($owner: String!, $repo: String!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequests(first: ${PER_PAGE}, orderBy: {field: UPDATED_AT, direction: DESC}, after: $after) {
                    nodes {
                      number
                      author { login }
                      createdAt
                      updatedAt
                      mergedAt
                      closedAt
                      merged
                      state
                    }
                    pageInfo { hasNextPage endCursor }
                  }
                }
              }
            `;

            // GraphQL query to fetch PRs with reviews (used for review counting)
            const allPRsQuery = `
              query($owner: String!, $repo: String!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequests(first: ${PER_PAGE}, orderBy: {field: UPDATED_AT, direction: DESC}, after: $after) {
                    nodes {
                      number
                      updatedAt
                      mergedAt
                      merged
                      reviews(first: 100) {
                        nodes {
                          submittedAt
                          author { login }
                        }
                      }
                    }
                    pageInfo { hasNextPage endCursor }
                  }
                }
              }
            `;

            // Fetch PRs (created/merged/closed this month)
            let allPRsThisMonth = [];
            let prHasNextPage = true;
            let prCursor = null;
            let prPageCount = 0;

            while (prHasNextPage && prPageCount < MAX_PAGES) {
              try {
                const result = await github.graphql(prQuery, { owner, repo, after: prCursor });
                const prs = result.repository.pullRequests;

                const monthPRs = prs.nodes.filter(prNode => {
                  const createdAt = new Date(prNode.createdAt);
                  const mergedAt = prNode.mergedAt ? new Date(prNode.mergedAt) : null;
                  const closedAt = prNode.closedAt ? new Date(prNode.closedAt) : null;

                  const createdThisMonth = createdAt >= startOfMonth && createdAt <= endOfMonth;
                  const mergedThisMonth = mergedAt && mergedAt >= startOfMonth && mergedAt <= endOfMonth;
                  const closedThisMonth = closedAt && closedAt >= startOfMonth && closedAt <= endOfMonth;

                  return createdThisMonth || mergedThisMonth || closedThisMonth;
                });

                allPRsThisMonth = allPRsThisMonth.concat(monthPRs);

                // Early exit if oldest updatedAt is before startOfMonth
                if (prs.nodes.length > 0) {
                  const oldestUpdatedAt = new Date(prs.nodes[prs.nodes.length - 1].updatedAt);
                  if (oldestUpdatedAt < startOfMonth) {
                    core.info(`Stopping PR pagination - reached PRs updated before ${startOfMonth.toISOString()}`);
                    prHasNextPage = false;
                  }
                }

                if (prHasNextPage) {
                  prHasNextPage = prs.pageInfo.hasNextPage;
                  prCursor = prs.pageInfo.endCursor;
                }
                prPageCount++;
              } catch (error) {
                core.warning(`Error fetching PRs: ${error.message}`);
                break;
              }
            }

            // Fetch recent PRs for review counting
            let allReviews = [];
            let recentPRsHasNextPage = true;
            let recentPRsCursor = null;
            let recentPRsPageCount = 0;

            while (recentPRsHasNextPage && recentPRsPageCount < MAX_PAGES) {
              try {
                const result = await github.graphql(allPRsQuery, { owner, repo, after: recentPRsCursor });
                const prs = result.repository.pullRequests;

                const recentPRs = prs.nodes.filter(prNode => {
                  const updatedAt = new Date(prNode.updatedAt);
                  return updatedAt >= threeMonthsAgo;
                });

                // Only count reviews if they are among the first two reviews on the PR
                for (const prNode of recentPRs) {
                  const allRevNodes = (prNode.reviews && prNode.reviews.nodes) ? prNode.reviews.nodes.filter(r => r.submittedAt) : [];

                  // Sort by submittedAt ascending (earliest first) and take first two overall
                  allRevNodes.sort((a, b) => new Date(a.submittedAt) - new Date(b.submittedAt));
                  const earliestTwo = allRevNodes.slice(0, 2);

                  // From those earliest two, only include ones that fall within this month
                  const monthFirstTwo = earliestTwo.filter(r => {
                    const dt = new Date(r.submittedAt);
                    return dt >= startOfMonth && dt <= endOfMonth;
                  });

                  // Push formatted reviews (skip bots later during aggregation)
                  for (const r of monthFirstTwo) {
                    allReviews.push({
                      submitted_at: r.submittedAt,
                      user: { login: r.author ? r.author.login : null }
                    });
                  }
                }

                // Early exit: if oldest PR updatedAt is older than three months, stop paginating
                const oldestPr = prs.nodes[prs.nodes.length - 1];
                if (oldestPr) {
                  const oldestUpdatedAt = new Date(oldestPr.updatedAt);
                  if (oldestUpdatedAt < threeMonthsAgo) {
                    core.info(`Stopping recent PRs pagination - reached PRs updated before ${threeMonthsAgo.toISOString()}`);
                    break;
                  }
                }

                recentPRsHasNextPage = prs.pageInfo.hasNextPage;
                recentPRsCursor = prs.pageInfo.endCursor;
                recentPRsPageCount++;
              } catch (error) {
                core.warning(`Error fetching recent PRs: ${error.message}`);
                break;
              }
            }

            // Fetch all issue comments for the month (repo-wide)
            let allComments = [];
            let commentPage = 1;

            while (commentPage <= MAX_PAGES) {
              try {
                const { data: comments } = await github.rest.issues.listCommentsForRepo({
                  owner, repo, since: startOfMonth.toISOString(), per_page: PER_PAGE, page: commentPage
                });

                if (comments.length === 0) break;

                const monthComments = comments.filter(comment => {
                  const dt = new Date(comment.created_at);
                  return dt >= startOfMonth && dt <= endOfMonth;
                });

                allComments = allComments.concat(monthComments);
                commentPage++;
              } catch (error) {
                core.warning(`Error fetching comments: ${error.message}`);
                break;
              }
            }

            // Separate PRs by type for scoring/metrics
            const createdPRs = allPRsThisMonth.filter(n => {
              const dt = new Date(n.createdAt);
              return dt >= startOfMonth && dt <= endOfMonth;
            });

            const mergedPRs = allPRsThisMonth.filter(n => {
              const dt = n.mergedAt ? new Date(n.mergedAt) : null;
              return dt && dt >= startOfMonth && dt <= endOfMonth;
            });

            const closedPRs = allPRsThisMonth.filter(n => {
              const dt = n.closedAt ? new Date(n.closedAt) : null;
              return dt && dt >= startOfMonth && dt <= endOfMonth && !n.merged;
            });

            core.info(`Found ${createdPRs.length} PRs created, ${mergedPRs.length} merged, ${closedPRs.length} closed (not merged), ${allReviews.length} eligible reviews (first two only), ${allComments.length} comments this month`);

            // Aggregate per-user stats
            const userStats = {};

            // Helper to init
            const ensureUser = (login) => {
              if (!userStats[login]) {
                userStats[login] = { totalPrs: 0, mergedPrs: 0, closedPrs: 0, reviews: 0, comments: 0, total: 0 };
              }
            };

            // Count Total PRs (created)
            for (const node of createdPRs) {
              if (node.author && node.author.login) {
                if (isBot({ login: node.author.login })) continue;
                ensureUser(node.author.login);
                userStats[node.author.login].totalPrs++;
              }
            }

            // Count merged PRs
            for (const node of mergedPRs) {
              if (node.author && node.author.login) {
                if (isBot({ login: node.author.login })) continue;
                ensureUser(node.author.login);
                userStats[node.author.login].mergedPrs++;
              }
            }

            // Count closed-but-not-merged PRs
            for (const node of closedPRs) {
              if (node.author && node.author.login) {
                if (isBot({ login: node.author.login })) continue;
                ensureUser(node.author.login);
                userStats[node.author.login].closedPrs++;
              }
            }

            // Count reviews (already filtered to earliest two per PR and this month)
            for (const review of allReviews) {
              if (review.user && review.user.login) {
                if (isBot({ login: review.user.login })) continue;
                ensureUser(review.user.login);
                userStats[review.user.login].reviews++;
              }
            }

            // Count comments
            for (const c of allComments) {
              if (c.user && c.user.login) {
                if (isBot({ login: c.user.login })) continue;
                ensureUser(c.user.login);
                userStats[c.user.login].comments++;
              }
            }

            // Scoring:
            // Total PRs: +1 (capped at 5), Merged PRs: +10, Closed PRs: -2, Reviews: +5, Comments: +2
            for (const login in userStats) {
              const cappedTotalPrs = Math.min(userStats[login].totalPrs, MAX_TOTAL_PRS_FOR_SCORING);
              userStats[login].total =
                (cappedTotalPrs * 1) +
                (userStats[login].mergedPrs * 10) +
                (userStats[login].closedPrs * -2) +
                (userStats[login].reviews * 5) +
                (userStats[login].comments * 2);
            }

            // Sort users
            const sortedUsers = Object.entries(userStats)
              .map(([login, stats]) => ({ login, ...stats }))
              .sort((a, b) => {
                if (b.total !== a.total) return b.total - a.total;
                if (b.mergedPrs !== a.mergedPrs) return b.mergedPrs - a.mergedPrs;
                if (b.reviews !== a.reviews) return b.reviews - a.reviews;
                return a.login.localeCompare(b.login, 'en-US', { sensitivity: 'base' });
              });

            const authorIndex = sortedUsers.findIndex(u => u.login === prAuthor);
            const displayMonth = startOfMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric', timeZone: 'UTC' });

            // Generate leaderboard comment
            const commentMarker = '<!-- leaderboard-bot -->';
            let commentBody = commentMarker + '\n';
            commentBody += '## ðŸ“Š Monthly Leaderboard\n\n';
            commentBody += `Hi @${prAuthor}! Here's how you rank for ${displayMonth}:\n\n`;

            if (authorIndex === -1) {
              commentBody += 'ðŸŽ‰ **Welcome!** This is your first contribution this month.\n\n';
              commentBody += '### Top 3 Contributors\n\n';
              commentBody += '| Rank | User | Total PRs | PRs (merged) | PRs (closed) | Reviews | Comments | Total |\n';
              commentBody += '|------|------|-----------|--------------|--------------|---------|----------|-------|\n';
              for (let i = 0; i < Math.min(3, sortedUsers.length); i++) {
                const u = sortedUsers[i];
                const medal = i === 0 ? 'ðŸ¥‡' : i === 1 ? 'ðŸ¥ˆ' : 'ðŸ¥‰';
                commentBody += `| ${medal} #${i + 1} | \`@${u.login}\` | ${u.totalPrs} | ${u.mergedPrs} | ${u.closedPrs} | ${u.reviews} | ${u.comments} | **${u.total}** |\n`;
              }
            } else {
              commentBody += '| Rank | User | Total PRs | PRs (merged) | PRs (closed) | Reviews | Comments | Total |\n';
              commentBody += '|------|------|-----------|--------------|--------------|---------|----------|-------|\n';

              if (authorIndex > 0) {
                const ua = sortedUsers[authorIndex - 1];
                const medal = authorIndex - 1 === 0 ? 'ðŸ¥‡' : authorIndex - 1 === 1 ? 'ðŸ¥ˆ' : authorIndex - 1 === 2 ? 'ðŸ¥‰' : '';
                commentBody += `| ${medal} #${authorIndex} | \`@${ua.login}\` | ${ua.totalPrs} | ${ua.mergedPrs} | ${ua.closedPrs} | ${ua.reviews} | ${ua.comments} | **${ua.total}** |\n`;
              }

              const uc = sortedUsers[authorIndex];
              const currentMedal = authorIndex === 0 ? 'ðŸ¥‡' : authorIndex === 1 ? 'ðŸ¥ˆ' : authorIndex === 2 ? 'ðŸ¥‰' : '';
              commentBody += `| ${currentMedal} **#${authorIndex + 1}** | **\`@${uc.login}\`** âœ¨ | **${uc.totalPrs}** | **${uc.mergedPrs}** | **${uc.closedPrs}** | **${uc.reviews}** | **${uc.comments}** | **${uc.total}** |\n`;

              if (authorIndex < sortedUsers.length - 1) {
                const ub = sortedUsers[authorIndex + 1];
                commentBody += `| #${authorIndex + 2} | \`@${ub.login}\` | ${ub.totalPrs} | ${ub.mergedPrs} | ${ub.closedPrs} | ${ub.reviews} | ${ub.comments} | **${ub.total}** |\n`;
              }
            }

            commentBody += '\n';
            commentBody += '---\n';
            commentBody += `*Leaderboard based on contributions in ${displayMonth}. **Scoring:** Total PRs (+1 pt, max 5), Merged PRs (+10 pts), Closed PRs (-2 pts), Reviews (+5 pts, first two per PR only), Comments (+2 pts). Keep up the great work! ðŸš€*\n`;

            // Upsert comment on the PR
            const { data: existingComments } = await github.rest.issues.listComments({
              owner, repo, issue_number: pull_number, per_page: PER_PAGE
            });

            const existingLeaderboardComment = existingComments.find(c => c.body && c.body.includes(commentMarker));

            if (existingLeaderboardComment) {
              await github.rest.issues.updateComment({
                owner, repo, comment_id: existingLeaderboardComment.id, body: commentBody
              });
              core.info(`Updated leaderboard comment on PR #${pull_number}`);
            } else {
              await github.rest.issues.createComment({
                owner, repo, issue_number: pull_number, body: commentBody
              });
              core.info(`Posted leaderboard comment on PR #${pull_number}`);
            }