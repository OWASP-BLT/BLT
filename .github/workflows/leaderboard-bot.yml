name: Leaderboard Bot

# Uses pull_request_target so it runs with base repo permissions for forked PRs.
# SECURITY: We do NOT check out or execute PR code. We only use the GitHub API.
on:
  pull_request_target:
    types:
      - opened

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  post_leaderboard:
    runs-on: ubuntu-latest
    env:
      # Coderabbit discussion encouragement (anti-abuse configurable)
      # visible | hidden | separate
      CR_DISCUSSION_MODE: visible
      # Max discussions counted per user in a month
      CR_DISCUSSION_LIMIT: '3'
      # Points per counted discussion (0 by default â€“ visibility first, enable later if desired)
      CR_DISCUSSION_POINTS: '0'
    steps:
      - name: Post Leaderboard Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr = context.payload.pull_request;
            const pull_number = pr.number;
            const prAuthor = pr.user.login;

            core.info(`Processing PR #${pull_number} by @${prAuthor}`);

            // Bot detection helper function
            const isBot = (user) => {
              if (!user || !user.login) return false;
              const loginLower = user.login.toLowerCase();
              const botPatterns = ['copilot', '[bot]', 'dependabot', 'github-actions', 'renovate', 'actions-user'];
              return (user.type && user.type === 'Bot') ||
                     botPatterns.some(pattern => loginLower.includes(pattern));
            };

            // Skip leaderboard for bot accounts
            if (isBot(pr.user)) {
              core.info(`Skipping leaderboard for bot account: @${prAuthor}`);
              return;
            }

            // POLICY: auto-close new PRs if author already has >= 10 open PRs
            const MAX_OPEN_PRS_PER_AUTHOR = 10;
            try {
              const searchRes = await github.rest.search.issuesAndPullRequests({
                q: `repo:${owner}/${repo} is:pr is:open author:${prAuthor}`,
                per_page: 100
              });
              const openItems = (searchRes.data && searchRes.data.items) ? searchRes.data.items : [];
              const preExistingOpenCount = openItems.filter(item => item.number !== pull_number).length;
              core.info(`Open PRs for @${prAuthor} (excluding current): ${preExistingOpenCount}`);

              if (preExistingOpenCount >= MAX_OPEN_PRS_PER_AUTHOR) {
                const msg = [
                  `Hi @${prAuthor}, thanks for your contribution!`,
                  ``,
                  `This PR is being auto-closed because you currently have ${preExistingOpenCount} open PRs in this repository (limit: ${MAX_OPEN_PRS_PER_AUTHOR}).`,
                  `Please finish or close some existing PRs before opening new ones.`,
                  ``,
                  `If you believe this was closed in error, please contact the maintainers.`
                ].join('\n');

                // Leave a comment explaining the closure
                await github.rest.issues.createComment({
                  owner, repo, issue_number: pull_number, body: msg
                });

                // Close the PR
                await github.rest.pulls.update({
                  owner, repo, pull_number, state: 'closed'
                });

                core.info(`Auto-closed PR #${pull_number} due to open PR limit.`);
                return; // stop further processing
              }
            } catch (e) {
              core.warning(`Failed to evaluate open PR limit for @${prAuthor}: ${e.message}`);
              // Continue even if limit check failed to avoid blocking regular behavior
            }

            // Get current month date range (UTC)
            const now = new Date();
            const startOfMonth = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), 1, 0, 0, 0, 0));
            const endOfMonth = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth() + 1, 0, 23, 59, 59, 999));
            const threeMonthsAgo = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth() - 3, 1));

            core.info(`Fetching stats for ${startOfMonth.toISOString()} to ${endOfMonth.toISOString()}`);

            // Config
            const MAX_PAGES = 10;
            const PER_PAGE = 100;

            const CR_MODE = (process.env.CR_DISCUSSION_MODE || 'visible').toLowerCase();
            const CR_LIMIT = parseInt(process.env.CR_DISCUSSION_LIMIT || '3', 10);
            const CR_POINTS = parseInt(process.env.CR_DISCUSSION_POINTS || '0', 10);

            // GraphQL: PRs updated recently (we filter to created/merged/closed in-month)
            const prQuery = `
              query($owner: String!, $repo: String!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequests(first: ${PER_PAGE}, orderBy: {field: UPDATED_AT, direction: DESC}, after: $after) {
                    nodes {
                      number
                      author { login }
                      createdAt
                      updatedAt
                      mergedAt
                      closedAt
                      merged
                      state
                    }
                    pageInfo { hasNextPage endCursor }
                  }
                }
              }
            `;

            // GraphQL: PRs with reviews (for approvals)
            const reviewsQuery = `
              query($owner: String!, $repo: String!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequests(first: ${PER_PAGE}, orderBy: {field: UPDATED_AT, direction: DESC}, after: $after) {
                    nodes {
                      number
                      updatedAt
                      reviews(first: 100) {
                        nodes {
                          submittedAt
                          state
                          author { login }
                        }
                      }
                    }
                    pageInfo { hasNextPage endCursor }
                  }
                }
              }
            `;

            // GraphQL: All OPEN PRs repo-wide (for +1 per open)
            const openPRsQuery = `
              query($owner: String!, $repo: String!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequests(states: OPEN, first: ${PER_PAGE}, orderBy: {field: UPDATED_AT, direction: DESC}, after: $after) {
                    nodes {
                      number
                      author { login }
                      createdAt
                      updatedAt
                    }
                    pageInfo { hasNextPage endCursor }
                  }
                }
              }
            `;

            // 1) Fetch PRs touching this month (created/merged/closed in-month)
            let allPRsThisMonth = [];
            let prHasNextPage = true;
            let prCursor = null;
            let prPageCount = 0;

            while (prHasNextPage && prPageCount < MAX_PAGES) {
              try {
                const result = await github.graphql(prQuery, { owner, repo, after: prCursor });
                const prs = result.repository.pullRequests;

                const monthPRs = prs.nodes.filter(prNode => {
                  const createdAt = new Date(prNode.createdAt);
                  const mergedAt = prNode.mergedAt ? new Date(prNode.mergedAt) : null;
                  const closedAt = prNode.closedAt ? new Date(prNode.closedAt) : null;

                  const createdThisMonth = createdAt >= startOfMonth && createdAt <= endOfMonth;
                  const mergedThisMonth = mergedAt && mergedAt >= startOfMonth && mergedAt <= endOfMonth;
                  const closedThisMonth = closedAt && closedAt >= startOfMonth && closedAt <= endOfMonth;

                  return createdThisMonth || mergedThisMonth || closedThisMonth;
                });

                allPRsThisMonth = allPRsThisMonth.concat(monthPRs);

                // Early exit if oldest updatedAt is before startOfMonth
                if (prs.nodes.length > 0) {
                  const oldestUpdatedAt = new Date(prs.nodes[prs.nodes.length - 1].updatedAt);
                  if (oldestUpdatedAt < startOfMonth) {
                    core.info(`Stopping PR pagination - reached PRs updated before ${startOfMonth.toISOString()}`);
                    prHasNextPage = false;
                  }
                }

                if (prHasNextPage) {
                  prHasNextPage = prs.pageInfo.hasNextPage;
                  prCursor = prs.pageInfo.endCursor;
                }
                prPageCount++;
              } catch (error) {
                core.warning(`Error fetching PRs: ${error.message}`);
                break;
              }
            }

            // 2) Fetch approvals (only first two APPROVED per PR; must be in-month)
            let approvals = [];
            let revHasNextPage = true;
            let revCursor = null;
            let revPageCount = 0;

            while (revHasNextPage && revPageCount < MAX_PAGES) {
              try {
                const result = await github.graphql(reviewsQuery, { owner, repo, after: revCursor });
                const prs = result.repository.pullRequests;

                for (const prNode of prs.nodes) {
                  const nodes = (prNode.reviews && prNode.reviews.nodes) ? prNode.reviews.nodes.filter(r => r.submittedAt && r.state) : [];
                  // Keep only APPROVED, sort by submittedAt asc, take first two
                  const approvalsAsc = nodes
                    .filter(r => r.state === 'APPROVED')
                    .sort((a, b) => new Date(a.submittedAt) - new Date(b.submittedAt))
                    .slice(0, 2);
                  // Month filter
                  const monthApprovals = approvalsAsc.filter(r => {
                    const dt = new Date(r.submittedAt);
                    return dt >= startOfMonth && dt <= endOfMonth;
                  });
                  for (const r of monthApprovals) {
                    approvals.push({ submitted_at: r.submittedAt, user: { login: r.author ? r.author.login : null } });
                  }
                }

                // Early exit: â‰¥ 3 months old pages are irrelevant to month approvals window
                const oldestPr = prs.nodes[prs.nodes.length - 1];
                if (oldestPr) {
                  const oldestUpdatedAt = new Date(oldestPr.updatedAt);
                  if (oldestUpdatedAt < threeMonthsAgo) {
                    core.info(`Stopping reviews pagination - reached PRs updated before ${threeMonthsAgo.toISOString()}`);
                    break;
                  }
                }

                revHasNextPage = prs.pageInfo.hasNextPage;
                revCursor = prs.pageInfo.endCursor;
                revPageCount++;
              } catch (error) {
                core.warning(`Error fetching reviews: ${error.message}`);
                break;
              }
            }

            // 3) Fetch repo comments for this month (for +2/comment and coderabbit discussions)
            let allComments = [];
            let commentPage = 1;
            while (commentPage <= MAX_PAGES) {
              try {
                const { data: comments } = await github.rest.issues.listCommentsForRepo({
                  owner, repo, since: startOfMonth.toISOString(), per_page: PER_PAGE, page: commentPage
                });

                if (comments.length === 0) break;

                const monthComments = comments.filter(comment => {
                  const dt = new Date(comment.created_at);
                  return dt >= startOfMonth && dt <= endOfMonth;
                });

                allComments = allComments.concat(monthComments);
                commentPage++;
              } catch (error) {
                core.warning(`Error fetching comments: ${error.message}`);
                break;
              }
            }

            // 4) Fetch all OPEN PRs (repo-wide) for +1 per open PR
            let openByUser = {};
            let openHasNext = true;
            let openCursor = null;
            let openPageCount = 0;

            while (openHasNext && openPageCount < MAX_PAGES) {
              try {
                const result = await github.graphql(openPRsQuery, { owner, repo, after: openCursor });
                const prs = result.repository.pullRequests;

                for (const n of prs.nodes) {
                  if (!n.author || !n.author.login) continue;
                  const login = n.author.login;
                  openByUser[login] = (openByUser[login] || 0) + 1;
                }

                openHasNext = prs.pageInfo.hasNextPage;
                openCursor = prs.pageInfo.endCursor;
                openPageCount++;
              } catch (error) {
                core.warning(`Error fetching open PRs: ${error.message}`);
                break;
              }
            }

            // Separate PRs by type (month-scoped for merged/closed)
            const mergedPRs = allPRsThisMonth.filter(n => {
              const dt = n.mergedAt ? new Date(n.mergedAt) : null;
              return dt && dt >= startOfMonth && dt <= endOfMonth;
            });

            const closedPRs = allPRsThisMonth.filter(n => {
              const dt = n.closedAt ? new Date(n.closedAt) : null;
              return dt && dt >= startOfMonth && dt <= endOfMonth && !n.merged;
            });

            // Aggregate per-user stats
            const userStats = {};
            const ensureUser = (login) => {
              if (!userStats[login]) {
                userStats[login] = { openPrs: 0, mergedPrs: 0, closedPrs: 0, approvals: 0, comments: 0, crChats: 0, crBonus: 0, total: 0 };
              }
            };

            // +1 per OPEN PR (repo-wide; no artificial cap)
            for (const [login, count] of Object.entries(openByUser)) {
              if (isBot({ login })) continue;
              ensureUser(login);
              userStats[login].openPrs += count;
            }

            // +10 per merged this month
            for (const node of mergedPRs) {
              if (node.author && node.author.login) {
                if (isBot({ login: node.author.login })) continue;
                ensureUser(node.author.login);
                userStats[node.author.login].mergedPrs++;
              }
            }

            // âˆ’2 per closed (not merged) this month
            for (const node of closedPRs) {
              if (node.author && node.author.login) {
                if (isBot({ login: node.author.login })) continue;
                ensureUser(node.author.login);
                userStats[node.author.login].closedPrs++;
              }
            }

            // +5 per approval (first two approvals per PR, month-scoped)
            for (const r of approvals) {
              if (r.user && r.user.login) {
                if (isBot({ login: r.user.login })) continue;
                ensureUser(r.user.login);
                userStats[r.user.login].approvals++;
              }
            }

            // +2 per repo comment this month
            for (const c of allComments) {
              if (c.user && c.user.login) {
                if (isBot({ login: c.user.login })) continue;
                ensureUser(c.user.login);
                userStats[c.user.login].comments++;
              }
            }

            // Coderabbit discussions (encouragement without misuse)
            const isCRPing = (body) => {
              if (!body) return false;
              const b = String(body).toLowerCase();
              return b.includes('coderabbit') || b.includes('@coderabbitai');
            };
            const crByUser = {};
            for (const c of allComments) {
              const login = c.user && c.user.login ? c.user.login : null;
              if (!login || isBot({ login })) continue;
              if (isCRPing(c.body)) {
                crByUser[login] = (crByUser[login] || 0) + 1;
              }
            }
            for (const [login, cnt] of Object.entries(crByUser)) {
              ensureUser(login);
              if (CR_MODE === 'visible') {
                const awarded = Math.min(cnt, CR_LIMIT) * CR_POINTS;
                userStats[login].crChats = cnt;
                userStats[login].crBonus = awarded;
              } else if (CR_MODE === 'hidden') {
                const awarded = (cnt >= CR_LIMIT) ? CR_POINTS : 0;
                userStats[login].crBonus = awarded;
              } else {
                // separate: compute but do not score
                userStats[login].crChats = cnt;
              }
            }

            // Final scoring
            // open: +1 each; merged: +10; closed: âˆ’2; approvals: +5; comments: +2; CR bonus per mode
            for (const login in userStats) {
              const s = userStats[login];
              s.total =
                (s.openPrs * 1) +
                (s.mergedPrs * 10) +
                (s.closedPrs * -2) +
                (s.approvals * 5) +
                (s.comments * 2) +
                (s.crBonus || 0);
            }

            // Sorting: by total, then merged PRs, then approvals, then alpha
            const sortedUsers = Object.entries(userStats)
              .map(([login, stats]) => ({ login, ...stats }))
              .sort((a, b) => {
                if (b.total !== a.total) return b.total - a.total;
                if (b.mergedPrs !== a.mergedPrs) return b.mergedPrs - a.mergedPrs;
                if (b.approvals !== a.approvals) return b.approvals - a.approvals;
                return a.login.localeCompare(b.login, 'en-US', { sensitivity: 'base' });
              });

            const authorIndex = sortedUsers.findIndex(u => u.login === prAuthor);
            const displayMonth = startOfMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric', timeZone: 'UTC' });

            // Generate leaderboard comment
            const commentMarker = '<!-- leaderboard-bot -->';
            let commentBody = commentMarker + '\n';
            commentBody += '## ðŸ“Š Monthly Leaderboard\n\n';
            commentBody += `Hi @${prAuthor}! Here's how you rank for ${displayMonth}:\n\n`;

            // Construct header based on CR mode/points visibility
            const showCRCol = (CR_MODE === 'visible');
            const headerCols = ['Rank', 'User', 'Open PRs', 'PRs (merged)', 'PRs (closed)', 'Approvals', 'Comments'];
            if (showCRCol) headerCols.push('CR chats');
            headerCols.push('Total');

            commentBody += `| ${headerCols.join(' | ')} |\n`;
            commentBody += `| ${headerCols.map(() => '---').join(' | ')} |\n`;

            const rowFor = (rankLabel, u, bold = false, medal = '') => {
              const userCell = bold ? `**\\`@${u.login}\\`** âœ¨` : `\\`@${u.login}\\``;
              const cells = [
                medal ? `${medal} ${rankLabel}` : `${rankLabel}`,
                userCell,
                `${u.openPrs}`,
                `${u.mergedPrs}`,
                `${u.closedPrs}`,
                `${u.approvals}`,
                `${u.comments}`
              ];
              if (showCRCol) cells.push(`${u.crChats || 0}`);
              cells.push(`**${u.total}**`);
              return `| ${cells.join(' | ')} |`;
            };

            if (authorIndex === -1) {
              // Show top 3
              for (let i = 0; i < Math.min(3, sortedUsers.length); i++) {
                const u = sortedUsers[i];
                const medal = i === 0 ? 'ðŸ¥‡' : i === 1 ? 'ðŸ¥ˆ' : i === 2 ? 'ðŸ¥‰' : '';
                commentBody += rowFor(`#${i + 1}`, u, false, 
