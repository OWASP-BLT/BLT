name: Leaderboard Bot

# Uses pull_request_target so it runs with base repo permissions for forked PRs.
# SECURITY: We do NOT check out or execute PR code. We only use the GitHub API.
on:
  pull_request_target:
    types:
      - opened

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  post_leaderboard:
    runs-on: ubuntu-latest
    steps:
      - name: Post Leaderboard Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr = context.payload.pull_request;
            const pull_number = pr.number;
            const prAuthor = pr.user.login;
            
            core.info(`Processing PR #${pull_number} by @${prAuthor}`);
            
            // Get current month date range
            const now = new Date();
            const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
            const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);
            
            // Calculate a reasonable lookback period for fetching PRs to check for reviews
            // We look back 3 months to catch reviews on older PRs while avoiding unbounded queries
            const threeMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 3, 1);
            
            core.info(`Fetching stats for ${startOfMonth.toISOString()} to ${endOfMonth.toISOString()}`);
            
            // Configuration constants
            const MAX_PAGES = 10;
            const PER_PAGE = 100;
            
            // Bot detection helper function
            const isBot = (user) => {
              if (!user || !user.login) return false;
              const knownBots = ['copilot', 'dependabot', 'github-actions'];
              return user.type === 'Bot' || 
                     user.login.endsWith('[bot]') || 
                     knownBots.includes(user.login.toLowerCase());
            };
            
            // GraphQL query to fetch PRs for the current month (for counting PR creations)
            const prQuery = `
              query($owner: String!, $repo: String!, $since: DateTime!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequests(first: ${PER_PAGE}, orderBy: {field: CREATED_AT, direction: DESC}, filterBy: {since: $since}, after: $after) {
                    nodes {
                      number
                      author {
                        login
                        ... on User {
                          type: __typename
                        }
                        ... on Bot {
                          type: __typename
                        }
                      }
                      createdAt
                    }
                    pageInfo {
                      hasNextPage
                      endCursor
                    }
                  }
                }
              }
            `;
            
            // GraphQL query to fetch ALL recent PRs (for counting reviews on any PR)
            // Filters to PRs updated in the last 3 months to avoid unbounded queries
            const allPRsQuery = `
              query($owner: String!, $repo: String!, $since: DateTime!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequests(first: ${PER_PAGE}, orderBy: {field: UPDATED_AT, direction: DESC}, filterBy: {since: $since}, after: $after) {
                    nodes {
                      number
                    }
                    pageInfo {
                      hasNextPage
                      endCursor
                    }
                  }
                }
              }
            `;
            
            // Fetch all PRs created in current month
            let allPRs = [];
            let prHasNextPage = true;
            let prCursor = null;
            let prPageCount = 0;
            
            while (prHasNextPage && prPageCount < MAX_PAGES) {
              const variables = {
                owner,
                repo,
                since: startOfMonth.toISOString(),
                after: prCursor
              };
              
              try {
                const result = await github.graphql(prQuery, variables);
                
                const prs = result.repository.pullRequests;
                allPRs = allPRs.concat(prs.nodes);
                prHasNextPage = prs.pageInfo.hasNextPage;
                prCursor = prs.pageInfo.endCursor;
                prPageCount++;
              } catch (error) {
                core.warning(`Error fetching PRs: ${error.message}`);
                break;
              }
            }
            
            // Fetch ALL recent PRs (for review counting) - these are PRs that might have reviews this month
            // Only fetch PRs updated in the last 3 months to avoid unbounded queries
            let allRecentPRs = [];
            let recentPRsHasNextPage = true;
            let recentPRsCursor = null;
            let recentPRsPageCount = 0;
            
            while (recentPRsHasNextPage && recentPRsPageCount < MAX_PAGES) {
              const variables = {
                owner,
                repo,
                since: threeMonthsAgo.toISOString(),
                after: recentPRsCursor
              };
              
              try {
                const result = await github.graphql(allPRsQuery, variables);
                
                const prs = result.repository.pullRequests;
                allRecentPRs = allRecentPRs.concat(prs.nodes);
                recentPRsHasNextPage = prs.pageInfo.hasNextPage;
                recentPRsCursor = prs.pageInfo.endCursor;
                recentPRsPageCount++;
              } catch (error) {
                core.warning(`Error fetching recent PRs: ${error.message}`);
                break;
              }
            }
            
            // Fetch all reviews for the month using REST API
            // Fetch reviews from ALL recent PRs, not just PRs created this month
            let allReviews = [];
            
            for (const pr of allRecentPRs) {
              try {
                if (!pr.number) continue;
                
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner,
                  repo,
                  pull_number: pr.number,
                  per_page: PER_PAGE
                });
                
                // Filter reviews from current month and with valid submitted_at
                const monthReviews = reviews.filter(review => {
                  if (!review.submitted_at) return false;
                  const reviewDate = new Date(review.submitted_at);
                  return reviewDate >= startOfMonth && reviewDate <= endOfMonth;
                });
                
                allReviews = allReviews.concat(monthReviews);
              } catch (error) {
                core.warning(`Error fetching reviews for PR #${pr.number}: ${error.message}`);
              }
            }
            
            // Fetch all issue comments for the month
            let allComments = [];
            let commentPage = 1;
            
            while (commentPage <= MAX_PAGES) { // Limit to MAX_PAGES for performance
              try {
                const { data: comments } = await github.rest.issues.listCommentsForRepo({
                  owner,
                  repo,
                  since: startOfMonth.toISOString(),
                  per_page: PER_PAGE,
                  page: commentPage
                });
                
                if (comments.length === 0) break;
                
                // Filter comments from current month
                const monthComments = comments.filter(comment => {
                  const commentDate = new Date(comment.created_at);
                  return commentDate >= startOfMonth && commentDate <= endOfMonth;
                });
                
                allComments = allComments.concat(monthComments);
                commentPage++;
              } catch (error) {
                core.warning(`Error fetching comments: ${error.message}`);
                break;
              }
            }
            
            core.info(`Found ${allPRs.length} PRs created this month, ${allRecentPRs.length} recent PRs checked for reviews, ${allReviews.length} reviews, ${allComments.length} comments`);
            
            // Calculate scores for each user
            const userStats = {};
            
            // Count PRs
            for (const pr of allPRs) {
              if (pr.author && pr.author.login) {
                // Skip bot accounts
                if (isBot(pr.author)) continue;
                
                const login = pr.author.login;
                if (!userStats[login]) {
                  userStats[login] = { prs: 0, reviews: 0, comments: 0, total: 0 };
                }
                userStats[login].prs++;
              }
            }
            
            // Count reviews
            for (const review of allReviews) {
              if (review.user && review.user.login) {
                // Skip bot accounts
                if (isBot(review.user)) continue;
                
                const login = review.user.login;
                if (!userStats[login]) {
                  userStats[login] = { prs: 0, reviews: 0, comments: 0, total: 0 };
                }
                userStats[login].reviews++;
              }
            }
            
            // Count comments
            for (const comment of allComments) {
              if (comment.user && comment.user.login) {
                // Skip bot accounts
                if (isBot(comment.user)) continue;
                
                const login = comment.user.login;
                if (!userStats[login]) {
                  userStats[login] = { prs: 0, reviews: 0, comments: 0, total: 0 };
                }
                userStats[login].comments++;
              }
            }
            
            // Calculate total scores
            for (const login in userStats) {
              userStats[login].total = userStats[login].prs + userStats[login].reviews + userStats[login].comments;
            }
            
            // Sort users by total score
            const sortedUsers = Object.entries(userStats)
              .map(([login, stats]) => ({ login, ...stats }))
              .sort((a, b) => {
                if (b.total !== a.total) return b.total - a.total;
                // Tie-breaker: more PRs is better
                if (b.prs !== a.prs) return b.prs - a.prs;
                // Secondary tie-breaker: more reviews is better
                if (b.reviews !== a.reviews) return b.reviews - a.reviews;
                // Final tie-breaker: alphabetical (case-insensitive, consistent)
                return a.login.localeCompare(b.login, 'en-US', { sensitivity: 'base' });
              });
            
            // Find the PR author's position
            const authorIndex = sortedUsers.findIndex(u => u.login === prAuthor);
            
            // Format the month/year for display
            const displayMonth = startOfMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            
            // Generate leaderboard comment
            const commentMarker = '<!-- leaderboard-bot -->';
            let commentBody = commentMarker + '\n';
            commentBody += '## ðŸ“Š Monthly Leaderboard\n\n';
            commentBody += `Hi @${prAuthor}! Here's how you rank for ${displayMonth}:\n\n`;
            
            if (authorIndex === -1) {
              commentBody += 'ðŸŽ‰ **Welcome!** This is your first contribution this month.\n\n';
              commentBody += '### Top 3 Contributors\n\n';
              commentBody += '| Rank | User | PRs | Reviews | Comments | Total |\n';
              commentBody += '|------|------|-----|---------|----------|-------|\n';
              
              for (let i = 0; i < Math.min(3, sortedUsers.length); i++) {
                const user = sortedUsers[i];
                const medal = i === 0 ? 'ðŸ¥‡' : i === 1 ? 'ðŸ¥ˆ' : 'ðŸ¥‰';
                commentBody += `| ${medal} #${i + 1} | @${user.login} | ${user.prs} | ${user.reviews} | ${user.comments} | **${user.total}** |\n`;
              }
            } else {
              commentBody += '| Rank | User | PRs | Reviews | Comments | Total |\n';
              commentBody += '|------|------|-----|---------|----------|-------|\n';
              
              // Show user above (if exists)
              if (authorIndex > 0) {
                const userAbove = sortedUsers[authorIndex - 1];
                const medal = authorIndex - 1 === 0 ? 'ðŸ¥‡' : authorIndex - 1 === 1 ? 'ðŸ¥ˆ' : authorIndex - 1 === 2 ? 'ðŸ¥‰' : '';
                commentBody += `| ${medal} #${authorIndex} | @${userAbove.login} | ${userAbove.prs} | ${userAbove.reviews} | ${userAbove.comments} | **${userAbove.total}** |\n`;
              }
              
              // Show current user
              const currentUser = sortedUsers[authorIndex];
              const currentMedal = authorIndex === 0 ? 'ðŸ¥‡' : authorIndex === 1 ? 'ðŸ¥ˆ' : authorIndex === 2 ? 'ðŸ¥‰' : '';
              commentBody += `| ${currentMedal} **#${authorIndex + 1}** | **@${currentUser.login}** âœ¨ | **${currentUser.prs}** | **${currentUser.reviews}** | **${currentUser.comments}** | **${currentUser.total}** |\n`;
              
              // Show user below (if exists)
              if (authorIndex < sortedUsers.length - 1) {
                const userBelow = sortedUsers[authorIndex + 1];
                commentBody += `| #${authorIndex + 2} | @${userBelow.login} | ${userBelow.prs} | ${userBelow.reviews} | ${userBelow.comments} | **${userBelow.total}** |\n`;
              }
            }
            
            commentBody += '\n';
            commentBody += '---\n';
            commentBody += `*Leaderboard based on contributions in ${displayMonth}. Keep up the great work! ðŸš€*\n`;
            
            // Check if we already commented
            const { data: existingComments } = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: pull_number,
              per_page: PER_PAGE
            });
            
            const existingLeaderboardComment = existingComments.find(comment =>
              comment.body && comment.body.includes(commentMarker)
            );
            
            if (existingLeaderboardComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existingLeaderboardComment.id,
                body: commentBody
              });
              core.info(`Updated leaderboard comment on PR #${pull_number}`);
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pull_number,
                body: commentBody
              });
              core.info(`Posted leaderboard comment on PR #${pull_number}`);
            }
