name: Label Linked Issue

# Uses pull_request_target so it runs with base repo permissions for forked PRs.
# SECURITY: We do NOT check out or execute PR code. We only use the GitHub API.
on:
  pull_request_target:
    types:
      - opened
      - edited
      - reopened
      - synchronize

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  pull-requests: write
  issues: write

jobs:
  label_linked_issue:
    runs-on: ubuntu-latest
    steps:
      - name: Add or remove linked-issue label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull_request in context. Skipping.');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pull_number = pr.number;
            const labelName = 'linked-issue';
            const labelColor = '0075ca';
            const labelDescription = 'PR has a linked GitHub issue';

            // Use GraphQL to get closing issues references
            const query = `
              query($owner: String!, $repo: String!, $pr: Int!) {
                repository(owner: $owner, name: $repo) {
                  pullRequest(number: $pr) {
                    closingIssuesReferences(first: 10) {
                      totalCount
                    }
                  }
                }
              }
            `;

            const result = await github.graphql(query, {
              owner,
              repo,
              pr: pull_number,
            });

            const count = result.repository.pullRequest.closingIssuesReferences.totalCount;
            const hasLinkedIssue = count > 0;
            core.info(`PR #${pull_number} has ${count} linked issue(s).`);

            // Ensure the label exists
            try {
              await github.rest.issues.getLabel({ owner, repo, name: labelName });
            } catch (e) {
              if (e.status === 404) {
                await github.rest.issues.createLabel({
                  owner,
                  repo,
                  name: labelName,
                  color: labelColor,
                  description: labelDescription,
                });
                core.info(`Created label "${labelName}"`);
              } else {
                throw e;
              }
            }

            // Get current labels on the PR
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner,
              repo,
              issue_number: pull_number,
              per_page: 100,
            });
            const hasLabel = currentLabels.some(l => l.name === labelName);

            if (hasLinkedIssue && !hasLabel) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: pull_number,
                labels: [labelName],
              });
              core.info(`Added label "${labelName}" to PR #${pull_number}`);
            } else if (!hasLinkedIssue && hasLabel) {
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: pull_number,
                  name: labelName,
                });
                core.info(`Removed label "${labelName}" from PR #${pull_number}`);
              } catch (err) {
                if (err.status !== 404) {
                  core.warning(`Failed to remove label: ${err.message}`);
                }
              }
            } else {
              core.info(`No label change needed for PR #${pull_number}`);
            }
