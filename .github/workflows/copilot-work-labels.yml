name: Copilot Work Status Labels

# Automatically manage labels on PRs and issues when Copilot starts and finishes work
# - When Copilot opens a PR: adds "Copilot started work" label to the PR and linked issue(s)
# - When Copilot pushes commits: updates "Copilot started work" label (work resumed)
# - When Copilot's PR is closed/merged: removes "Copilot started work" and adds "Copilot finished work" label
on:
  pull_request_target:
    types: [opened, reopened, synchronize, closed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to update labels for'
        required: true
        type: number

# Security Note: Using pull_request_target is safe here because:
# 1. We only process PRs from trusted Copilot bot accounts
# 2. We immediately exit if PR author doesn't match Copilot pattern
# 3. We don't check out or execute any PR code
# 4. We only perform label management via GitHub API

permissions:
  issues: write  # Required to add/remove labels on both PRs and issues
  pull-requests: read

jobs:
  manage_copilot_labels:
    runs-on: ubuntu-latest
    steps:
      - name: Manage Copilot Work Labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Get PR from context or workflow_dispatch input
            let pr = context.payload.pull_request;
            let action = context.payload.action;

            // Handle workflow_dispatch trigger
            if (!pr && context.payload.inputs && context.payload.inputs.pr_number) {
              const prNumber = parseInt(context.payload.inputs.pr_number, 10);
              core.info(`Manual trigger for PR #${prNumber}`);

              const { data: prData } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber
              });
              pr = prData;
              // Treat manual dispatch as a synchronize event (work resumed)
              action = 'synchronize';
            }

            if (!pr) {
              core.info('No pull_request in context. Skipping.');
              return;
            }

            const prAuthor = pr.user.login.toLowerCase();

            // First, ensure the author is a GitHub bot account (type 'Bot' and/or '[bot]' suffix)
            const isBotAccount =
              (pr.user.type && pr.user.type.toLowerCase() === 'bot') ||
              pr.user.login.toLowerCase().endsWith('[bot]');

            // Then, match official Copilot accounts: 'copilot', 'copilot-*' (e.g., copilot-swe-agent)
            // This prevents false matches like 'mycopilot' or 'notcopilot' and prevents spoofing
            const isCopilot = isBotAccount && (prAuthor === 'copilot' || prAuthor.startsWith('copilot-'));

            if (!isCopilot) {
              core.info(`PR #${pr.number} is not from a trusted Copilot bot (author: ${pr.user.login}), skipping.`);
              return;
            }

            core.info(`Processing Copilot PR #${pr.number} (action: ${action})`);

            // Label names and colors
            const STARTED_LABEL = 'Copilot started work';
            const FINISHED_LABEL = 'Copilot finished work';
            const STARTED_COLOR = '0366d6'; // Blue
            const FINISHED_COLOR = '28a745'; // Green

            // Ensure labels exist in the repository
            async function ensureLabel(labelName, color, description) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: labelName });
                core.info(`Label "${labelName}" already exists`);
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({
                    owner, repo,
                    name: labelName,
                    color: color,
                    description: description
                  });
                  core.info(`Created label "${labelName}"`);
                } else {
                  throw e;
                }
              }
            }

            // Extract issue numbers from PR body (supports "fixes #123", "closes #456", etc.)
            function extractLinkedIssues(prBody) {
              if (!prBody) return [];
              // Regex matches GitHub's issue linking keywords with optional colon and whitespace
              // Supports: fixes #123, closes #456, resolves #789, fix: #123, etc.
              const regex = /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)[\s:]+#(\d+)/gi;
              const matches = [...prBody.matchAll(regex)];
              return [...new Set(matches.map(m => parseInt(m[1], 10)))];
            }

            // Find linked issues via timeline API
            async function findLinkedIssues(prNumber) {
              try {
                const allTimelineEvents = await github.paginate(
                  github.rest.issues.listEventsForTimeline,
                  {
                    owner, repo,
                    issue_number: prNumber,
                    per_page: 100
                  }
                );

                const linked = new Set();
                for (const event of allTimelineEvents) {
                  // Filter for 'connected' events that link to issues (not PRs)
                  if (event.event === 'connected' && event.issue && !event.issue.pull_request) {
                    linked.add(event.issue.number);
                  }
                }
                return Array.from(linked);
              } catch (e) {
                core.warning(`Failed to get timeline for PR #${prNumber}: ${e.message}`);
                return [];
              }
            }

            // Add label to issue
            async function addLabel(issueNumber, labelName) {
              try {
                const issue = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });

                // Check if label already exists on the issue
                const hasLabel = issue.data.labels.some(l => l.name === labelName);
                if (hasLabel) {
                  core.info(`  Issue #${issueNumber} already has label "${labelName}"`);
                  return;
                }

                await github.rest.issues.addLabels({
                  owner, repo,
                  issue_number: issueNumber,
                  labels: [labelName]
                });
                core.info(`  Added label "${labelName}" to issue #${issueNumber}`);
              } catch (e) {
                core.warning(`  Failed to add label to issue #${issueNumber}: ${e.message}`);
              }
            }

            // Remove label from issue
            async function removeLabel(issueNumber, labelName) {
              try {
                await github.rest.issues.removeLabel({
                  owner, repo,
                  issue_number: issueNumber,
                  name: labelName
                });
                core.info(`  Removed label "${labelName}" from issue #${issueNumber}`);
              } catch (e) {
                // Ignore 404 errors (label not found on issue)
                if (e.status === 404) {
                  core.info(`  Label "${labelName}" not found on issue #${issueNumber}`);
                } else {
                  core.warning(`  Failed to remove label from issue #${issueNumber}: ${e.message}`);
                }
              }
            }

            // Ensure both labels exist
            await ensureLabel(STARTED_LABEL, STARTED_COLOR, 'Copilot has started working on this issue');
            await ensureLabel(FINISHED_LABEL, FINISHED_COLOR, 'Copilot has finished working on this issue');

            // Get linked issues from PR body and timeline
            const bodyIssues = extractLinkedIssues(pr.body);
            const timelineIssues = await findLinkedIssues(pr.number);
            const linkedIssues = [...new Set([...bodyIssues, ...timelineIssues])];

            // Always label the PR itself, plus any linked issues
            const itemsToLabel = [pr.number, ...linkedIssues];

            if (linkedIssues.length === 0) {
              core.info('No linked issues found, will label PR only');
            } else {
              core.info(`Found ${linkedIssues.length} linked issue(s): ${linkedIssues.join(', ')}`);
            }

            const labelTarget = linkedIssues.length > 0
              ? `PR #${pr.number} and ${linkedIssues.length} linked issue(s)`
              : `PR #${pr.number} only`;
            core.info(`Will label ${labelTarget}`);

            // Handle PR opened/reopened - add "started work" label
            if (action === 'opened' || action === 'reopened') {
              core.info('PR opened/reopened - adding "Copilot started work" label');

              for (const itemNumber of itemsToLabel) {
                // Remove "finished work" label to ensure mutually exclusive states
                // (no-op on first open, relevant when reopening a closed PR)
                await removeLabel(itemNumber, FINISHED_LABEL);
                await addLabel(itemNumber, STARTED_LABEL);
              }
            }

            // Handle PR synchronize - ensure "started work" label is present (work resumed)
            if (action === 'synchronize') {
              core.info('PR updated with new commits - ensuring "Copilot started work" label is present');

              for (const itemNumber of itemsToLabel) {
                // Remove "finished work" label if present (Copilot resumed work)
                await removeLabel(itemNumber, FINISHED_LABEL);
                await addLabel(itemNumber, STARTED_LABEL);
              }
            }

            // Handle PR closed - remove "started" and add "finished" label
            if (action === 'closed') {
              core.info('PR closed - removing "Copilot started work" and adding "Copilot finished work" label');

              for (const itemNumber of itemsToLabel) {
                await removeLabel(itemNumber, STARTED_LABEL);
                await addLabel(itemNumber, FINISHED_LABEL);
              }
            }

            core.info('âœ… Copilot work status labels updated successfully');
