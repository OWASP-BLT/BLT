name: Add Migrations Label

# Uses pull_request_target so it runs with base repo permissions for forked PRs.
# SECURITY: We do NOT check out or execute PR code. We only use the GitHub API.
on:
  pull_request_target:
    types:
      - opened
      - synchronize
      - reopened

# Prevent multiple workflow runs for the same PR
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  add_migrations_label:
    runs-on: ubuntu-latest
    steps:
      - name: Check for Migrations and Add Label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull_request in context. Skipping.');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pull_number = pr.number;

            // Get all files changed in the PR (with pagination)
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number,
              per_page: 100,
            });

            // Check if any migration files are present
            // Migration files are in website/migrations/ or comments/migrations/
            const migrationPattern = /^(website|comments)\/migrations\/.*\.py$/;
            const migrationNumberPattern = /^(website|comments)\/migrations\/(\d{4})_.*\.py$/;
            
            const migrationFiles = files.filter(file => 
              migrationPattern.test(file.filename) && 
              !file.filename.endsWith('__init__.py')
            );
            const hasMigrations = migrationFiles.length > 0;

            // Define possible labels
            const sequenceOkLabel = 'migration: sequence-ok';
            const clashLabel = 'migration: clash';
            const oldLabel = 'migrations';
            const allMigrationLabels = [sequenceOkLabel, clashLabel, oldLabel];

            // Get current labels on the PR
            const { data: current } = await github.rest.issues.listLabelsOnIssue({ 
              owner, 
              repo, 
              issue_number: pull_number, 
              per_page: 100 
            });
            const currentNames = new Set(current.map(l => l.name));

            // Ensure labels exist (create if missing)
            async function ensureLabelExists(labelName, color, desc) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: labelName });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: labelName,
                    color: color,
                    description: desc,
                  });
                  core.info(`Created label ${labelName}`);
                } else {
                  throw e;
                }
              }
            }

            // Remove old/incorrect labels
            async function removeOldLabels(exceptLabel) {
              for (const label of allMigrationLabels) {
                if (label !== exceptLabel && currentNames.has(label)) {
                  try {
                    await github.rest.issues.removeLabel({ 
                      owner, 
                      repo, 
                      issue_number: pull_number, 
                      name: label 
                    });
                    core.info(`Removed label ${label} from PR #${pull_number}`);
                  } catch (err) {
                    if (err.status !== 404) {
                      core.warning(`Failed to remove label ${label}: ${err.message}`);
                    }
                  }
                }
              }
            }

            if (hasMigrations) {
              core.info(`Found migration files: ${migrationFiles.map(f => f.filename).join(', ')}`);

              // Extract migration numbers from PR files
              const prMigrationsByApp = {};
              for (const file of migrationFiles) {
                const match = file.filename.match(migrationNumberPattern);
                if (match) {
                  const app = match[1]; // 'website' or 'comments'
                  const migrationNum = match[2];
                  if (!prMigrationsByApp[app]) {
                    prMigrationsByApp[app] = [];
                  }
                  prMigrationsByApp[app].push({
                    number: migrationNum,
                    filename: file.filename
                  });
                }
              }

              // Get existing migration files from base branch
              const baseBranch = pr.base.ref;
              const baseMigrationsByApp = {};
              
              for (const app of ['website', 'comments']) {
                try {
                  const { data: contents } = await github.rest.repos.getContent({
                    owner,
                    repo,
                    path: `${app}/migrations`,
                    ref: baseBranch
                  });
                  
                  baseMigrationsByApp[app] = contents
                    .filter(file => file.type === 'file' && file.name.endsWith('.py') && file.name !== '__init__.py')
                    .map(file => {
                      const match = file.name.match(/^(\d{4})_.*\.py$/);
                      return match ? { number: match[1], filename: file.name } : null;
                    })
                    .filter(Boolean);
                  
                  core.info(`Base ${app}/migrations has ${baseMigrationsByApp[app].length} migrations`);
                } catch (err) {
                  if (err.status === 404) {
                    core.info(`No migrations directory found for ${app} in base branch`);
                    baseMigrationsByApp[app] = [];
                  } else {
                    throw err;
                  }
                }
              }

              // Check for conflicts
              let hasConflicts = false;
              const conflicts = [];
              
              for (const [app, prMigrations] of Object.entries(prMigrationsByApp)) {
                const baseMigrations = baseMigrationsByApp[app] || [];
                const baseMigrationNumbers = new Set(baseMigrations.map(m => m.number));
                
                for (const prMigration of prMigrations) {
                  if (baseMigrationNumbers.has(prMigration.number)) {
                    hasConflicts = true;
                    const baseFile = baseMigrations.find(m => m.number === prMigration.number);
                    conflicts.push({
                      app,
                      number: prMigration.number,
                      prFile: prMigration.filename,
                      baseFile: `${app}/migrations/${baseFile.filename}`
                    });
                    core.warning(
                      `Migration conflict detected: ${prMigration.filename} conflicts with ${baseFile.filename}`
                    );
                  }
                }
              }

              // Apply appropriate label
              if (hasConflicts) {
                // Create and apply clash label
                await ensureLabelExists(
                  clashLabel, 
                  'd73a4a', // Red color
                  'Migration number conflicts with base branch'
                );
                
                if (!currentNames.has(clashLabel)) {
                  await github.rest.issues.addLabels({ 
                    owner, 
                    repo, 
                    issue_number: pull_number, 
                    labels: [clashLabel] 
                  });
                  core.info(`Applied label ${clashLabel} to PR #${pull_number}`);
                }
                
                // Remove other migration labels
                await removeOldLabels(clashLabel);
                
                // Add comment explaining the conflict
                const conflictDetails = conflicts.map(c => 
                  '- `' + c.prFile + '` conflicts with `' + c.baseFile + '`'
                ).join('\n');
                
                const commentBody = '## ⚠️ Migration Conflict Detected\n\n' +
                  'This PR has migration files that conflict with existing migrations in the base branch:\n\n' +
                  conflictDetails + '\n\n' +
                  '### How to resolve:\n\n' +
                  '1. Delete the conflicting migration file(s) from your branch\n' +
                  '2. Pull the latest changes from the base branch\n' +
                  '3. Run `python manage.py makemigrations --merge` to create a merge migration\n' +
                  '4. Commit and push the merge migration\n\n' +
                  'Alternatively, you can:\n' +
                  '- Delete your migration file(s) and regenerate them with the next available migration number\n' +
                  '- Use the `regenerate-migrations` label to have migrations automatically regenerated\n\n' +
                  'For more information, see the [Django documentation on migration conflicts](https://docs.djangoproject.com/en/stable/topics/migrations/#migration-files).';

                // Check if we already posted a similar comment
                const { data: comments } = await github.rest.issues.listComments({
                  owner,
                  repo,
                  issue_number: pull_number,
                  per_page: 100
                });
                
                const botComments = comments.filter(c => 
                  c.user.type === 'Bot' && 
                  c.body.includes('Migration Conflict Detected')
                );
                
                if (botComments.length === 0) {
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: pull_number,
                    body: commentBody
                  });
                  core.info('Posted comment about migration conflicts');
                } else {
                  core.info('Comment about migration conflicts already exists');
                }
              } else {
                // No conflicts - apply sequence-ok label
                await ensureLabelExists(
                  sequenceOkLabel, 
                  '0e8a16', // Green color
                  'Migrations are correctly sequenced'
                );
                
                if (!currentNames.has(sequenceOkLabel)) {
                  await github.rest.issues.addLabels({ 
                    owner, 
                    repo, 
                    issue_number: pull_number, 
                    labels: [sequenceOkLabel] 
                  });
                  core.info(`Applied label ${sequenceOkLabel} to PR #${pull_number}`);
                }
                
                // Remove other migration labels
                await removeOldLabels(sequenceOkLabel);
              }
            } else {
              // No migrations found - remove all migration labels
              core.info(`No migrations found in PR #${pull_number}`);
              await removeOldLabels(null);
            }
