name: Add Migrations Label

# Uses pull_request_target so it runs with base repo permissions for forked PRs.
# SECURITY: We do NOT check out or execute PR code. We only use the GitHub API.
on:
  pull_request_target:
    types:
      - opened
      - synchronize
      - reopened

# Prevent multiple workflow runs for the same PR
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  add_migrations_label:
    runs-on: ubuntu-latest
    steps:
      - name: Check for Migrations and Add Label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull_request in context. Skipping.');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pull_number = pr.number;

            // Get all files changed in the PR (with pagination)
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number,
              per_page: 100,
            });

            // Check if any migration files are present
            // Migration files are in website/migrations/ or comments/migrations/
            const migrationPattern = /^(website|comments)\/migrations\/(\d{4})_.*\.py$/;
            const migrationFiles = files.filter(file => 
              migrationPattern.test(file.filename) && 
              !file.filename.endsWith('__init__.py')
            );
            const hasMigrations = migrationFiles.length > 0;

            const migrationsLabel = 'migrations';
            const labelColor = 'fbca04'; // Yellow color for visibility
            const description = 'PR contains database migration files';

            // Get current labels on the PR
            const { data: current } = await github.rest.issues.listLabelsOnIssue({ 
              owner, 
              repo, 
              issue_number: pull_number, 
              per_page: 100 
            });
            const currentNames = new Set(current.map(l => l.name));

            // Ensure the label exists (create if missing)
            async function ensureLabelExists(labelName, color, desc) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: labelName });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: labelName,
                    color: color,
                    description: desc,
                  });
                  core.info(`Created label ${labelName}`);
                } else {
                  throw e;
                }
              }
            }

            await ensureLabelExists(migrationsLabel, labelColor, description);

            if (hasMigrations) {
              // Log which migration files were found
              core.info(`Found migration files: ${migrationFiles.map(f => f.filename).join(', ')}`);

              // Add the label if it isn't already present
              if (!currentNames.has(migrationsLabel)) {
                await github.rest.issues.addLabels({ 
                  owner, 
                  repo, 
                  issue_number: pull_number, 
                  labels: [migrationsLabel] 
                });
                core.info(`Applied label ${migrationsLabel} to PR #${pull_number}`);
              } else {
                core.info(`Label ${migrationsLabel} already present on PR #${pull_number}`);
              }

              // Check for migration number overlaps
              // Extract migration numbers from PR files
              const prMigrations = {};
              for (const file of migrationFiles) {
                const match = file.filename.match(migrationPattern);
                if (match) {
                  const app = match[1]; // 'website' or 'comments'
                  const number = parseInt(match[2], 10);
                  if (!prMigrations[app]) {
                    prMigrations[app] = [];
                  }
                  prMigrations[app].push({ number, filename: file.filename });
                }
              }

              // Get existing migrations from base branch
              const baseBranch = pr.base.ref;
              const conflicts = [];

              for (const app of Object.keys(prMigrations)) {
                try {
                  // Get the migrations directory from base branch
                  const { data: baseMigrations } = await github.rest.repos.getContent({
                    owner,
                    repo,
                    path: `${app}/migrations`,
                    ref: baseBranch,
                  });

                  // Extract existing migration numbers
                  const existingNumbers = baseMigrations
                    .filter(file => file.type === 'file' && /^\d{4}_.*\.py$/.test(file.name) && file.name !== '__init__.py')
                    .map(file => {
                      const match = file.name.match(/^(\d{4})_/);
                      return match ? parseInt(match[1], 10) : null;
                    })
                    .filter(num => num !== null);

                  const maxExisting = existingNumbers.length > 0 ? Math.max(...existingNumbers) : 0;
                  core.info(`${app}: Max existing migration number is ${maxExisting}`);

                  // Check for conflicts
                  for (const prMigration of prMigrations[app]) {
                    if (prMigration.number <= maxExisting) {
                      conflicts.push({
                        app,
                        filename: prMigration.filename,
                        number: prMigration.number,
                        maxExisting,
                      });
                    }
                  }
                } catch (error) {
                  core.warning(`Could not fetch existing migrations for ${app}: ${error.message}`);
                }
              }

              // If there are conflicts, add a comment to the PR
              if (conflicts.length > 0) {
                const conflictMessages = conflicts.map(c => 
                  `- \`${c.filename}\` has migration number **${String(c.number).padStart(4, '0')}**, but the latest migration in \`${c.app}/migrations\` is **${String(c.maxExisting).padStart(4, '0')}**`
                ).join('\n');

                const commentBody = `## ⚠️ Migration Number Conflict Detected

This PR contains migration files with numbers that overlap with existing migrations in the base branch:

${conflictMessages}

### What this means:
Migration files must be numbered sequentially. The migration numbers in this PR are lower than or equal to existing migrations, which will cause conflicts.

### How to fix:
1. Delete the migration files in this PR
2. Rebase your branch on the latest \`${baseBranch}\` branch
3. Run \`python manage.py makemigrations\` again to generate new migration files with correct sequential numbers

This ensures your migrations will be applied in the correct order and won't conflict with existing migrations.`;

                // Check if we've already posted this comment
                const { data: comments } = await github.rest.issues.listComments({
                  owner,
                  repo,
                  issue_number: pull_number,
                });

                const botComment = comments.find(comment => 
                  comment.user.type === 'Bot' && 
                  comment.body.includes('Migration Number Conflict Detected')
                );

                if (botComment) {
                  // Update existing comment
                  await github.rest.issues.updateComment({
                    owner,
                    repo,
                    comment_id: botComment.id,
                    body: commentBody,
                  });
                  core.info('Updated existing migration conflict comment');
                } else {
                  // Create new comment
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: pull_number,
                    body: commentBody,
                  });
                  core.info('Posted new migration conflict comment');
                }

                core.setFailed(`Migration number conflicts detected. See PR comment for details.`);
              } else {
                core.info('✅ All migration numbers are sequential and valid');
                
                // Remove any existing conflict comment if migrations are now valid
                const { data: comments } = await github.rest.issues.listComments({
                  owner,
                  repo,
                  issue_number: pull_number,
                });

                const botComment = comments.find(comment => 
                  comment.user.type === 'Bot' && 
                  comment.body.includes('Migration Number Conflict Detected')
                );

                if (botComment) {
                  await github.rest.issues.deleteComment({
                    owner,
                    repo,
                    comment_id: botComment.id,
                  });
                  core.info('Deleted resolved migration conflict comment');
                }
              }
            } else {
              // Remove the label if no migrations are present
              if (currentNames.has(migrationsLabel)) {
                try {
                  await github.rest.issues.removeLabel({ 
                    owner, 
                    repo, 
                    issue_number: pull_number, 
                    name: migrationsLabel 
                  });
                  core.info(`Removed label ${migrationsLabel} from PR #${pull_number}`);
                } catch (err) {
                  // Ignore error if label doesn't exist
                  if (err.status !== 404) {
                    core.warning(`Failed to remove label ${migrationsLabel}: ${err.message}`);
                  }
                }
              } else {
                core.info(`No migrations found - label ${migrationsLabel} not present on PR #${pull_number}`);
              }
            }
