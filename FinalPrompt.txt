You are an AI agent designed to perform detailed reviews of GitHub pull requests. Given the following information, generate a professional, comprehensive review comment that evaluates the pull request thoroughly, highlighting strengths, weaknesses, and suggestions for improvement. Use a professional and constructive tone throughout your review. 

**Input:**

PR title: Aibot embedding

PR body: Not found

PR diff: 
Modified: .gitignore
@@ -20,3 +20,5 @@ requirements.txt
 *.exe
 .vs
 .qodo
+embeddings.json
+

Modified: blt/settings.py
@@ -23,6 +23,11 @@
 
 PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
 GITHUB_TOKEN = os.environ.get("GITHUB_TOKEN", "blank")
+GITHUB_AIBOT_WEBHOOK_URL = os.environ.get("GITHUB_AIBOT_WEBHOOK_URL", "blank")
+GITHUB_AIBOT_WEBHOOK_ID = os.environ.get("GITHUB_AIBOT_WEBHOOK_ID", "blank")
+GITHUB_AIBOT_TOKEN = os.environ.get("GITHUB_AIBOT_TOKEN", "blank")
+GITHUB_AIBOT_WEBHOOK_SECRET = os.environ.get("GITHUB_AIBOT_WEBHOOK_SECRET", "blank")
+GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY", "blank")
 DISCORD_BOT_TOKEN = os.environ.get("DISCORD_BOT_TOKEN", "blank")
 
 
@@ -49,9 +54,12 @@
 BLOG_URL = os.environ.get("BLOG_URL", FQDN + "/blog/")
 FACEBOOK_URL = os.environ.get("FACEBOOK_URL", "https://www.facebook.com/groups/owaspfoundation/")
 TWITTER_URL = os.environ.get("TWITTER_URL", "https://twitter.com/owasp_blt")
-GITHUB_URL = os.environ.get("GITHUB_URL", "https://github.com/OWASP/BLT")
+GITHUB_URL = os.environ.get("GITHUB_URL", "https://github.com/SahilDhillon21/BLT")
+GITHUB_API_URL = os.environ.get("GITHUB_API_URL", "https://api.github.com/repos/SahilDhillon21/BLT")
 EXTENSION_URL = os.environ.get("EXTENSION_URL", "https://github.com/OWASP/BLT-Extension")
 
+GITHUB_AIBOT_APP_NAME = "blt-ai-bot"
+
 ADMINS = (("Admin", DEFAULT_FROM_EMAIL),)
 
 SECRET_KEY = "i+acxn5(akgsn!sr4^qgf(^m&*@+g1@u^t@=8s@axc41ml*f=s"

Modified: blt/urls.py
@@ -39,6 +39,7 @@
     UserIssueViewSet,
     UserProfileViewSet,
 )
+from website.views.aibot import aibot_webhook_is_healthy, main_github_aibot_webhook_dispatcher
 from website.views.banned_apps import BannedAppsView, search_banned_apps
 from website.views.bitcoin import (
     BaconSubmissionView,
@@ -464,6 +465,8 @@
         organization_dashboard_hunt_edit,
         name="organization_dashboard_hunt_edit",
     ),
+    path("aibot", main_github_aibot_webhook_dispatcher, name="main_github_aibot_webhook_dispatcher"),
+    path("aibot_webhook_is_healthy", aibot_webhook_is_healthy, name="aibot_webhook_is_healthy"),
     path(
         "dashboard/admin/organization/<int:pk>/",
         admin_organization_dashboard_detail,

New: check_embedding_similarity.py
import json

import numpy as np


def cosine_similarity(a, b):
    """Calculate cosine similarity between two vectors."""
    a = np.array(a)
    b = np.array(b)

    norm_a = np.linalg.norm(a)
    norm_b = np.linalg.norm(b)

    if norm_a == 0 or norm_b == 0:
        return 0.0

    return np.dot(a, b) / (norm_a * norm_b)


def get_embedding(item):
    """Extract the embedding list from an item."""
    emb = item.get("embedding")
    if isinstance(emb, dict):
        return emb.get("embedding")
    return emb


def main():
    try:
        with open("embeddings.json", "r", encoding="utf-8") as f:
            data = json.load(f)
    except Exception as e:
        print(f"Error reading embeddings.json: {e}")
        return
    grouped = {}
    for item in data:
        content_type = item["content"]["type"]
        embedding = get_embedding(item)

        if embedding is not None:
            if content_type not in grouped:
                grouped[content_type] = []
            grouped[content_type].append((item, embedding))

    for content_type, items in grouped.items():
        if len(items) >= 2:
            (item1, emb1), (item2, emb2) = items[:2]
            sim = cosine_similarity(emb1, emb2)
            print(f"Similarity for type '{content_type}': {sim:.4f}")
            print(f"  '{item1['content']['chunk'][:60]}...' vs '{item2['content']['chunk'][:60]}...'")

    import_item = grouped.get("import")
    function_item = grouped.get("function")

    if import_item and function_item:
        (item1, emb1) = import_item[0]
        (item2, emb2) = function_item[0]
        sim = cosine_similarity(emb1, emb2)
        print(f"\nSimilarity between first import and first function: {sim:.4f}")
        print(f"  '{item1['content']['chunk'][:60]}...' vs '{item2['content']['chunk'][:60]}...'")
    else:
        print("\nNot enough data to compare import and function chunks.")


if __name__ == "__main__":
    main()

New: chunk_trial_script.py
import ast


def chunk_python_file(content: str, file_path: str):
    tree = ast.parse(content)
    lines = content.splitlines()
    chunks = []
    covered_lines = set()

    for node in ast.iter_child_nodes(tree):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
            if hasattr(node, "decorator_list") and node.decorator_list:
                decorator_lines = [decorator.lineno for decorator in node.decorator_list]
                start_line = min(decorator_lines) - 1
            else:
                start_line = node.lineno - 1
            end_line = node.end_lineno
            for i in range(start_line, end_line):
                covered_lines.add(i)
            code_chunk = "\n".join(lines[start_line:end_line])
            chunks.append(
                {
                    "type": "class" if isinstance(node, ast.ClassDef) else "function",
                    "name": getattr(node, "name", None),
                    "chunk": code_chunk,
                    "file": file_path,
                    "start_line": start_line + 1,
                    "end_line": end_line,
                }
            )
        elif isinstance(node, (ast.Import, ast.ImportFrom)):
            start_line = node.lineno - 1
            end_line = node.end_lineno if node.end_lineno else node.lineno
            for i in range(start_line, end_line):
                covered_lines.add(i)
            code_chunk = "\n".join(lines[start_line:end_line])
            chunks.append(
                {
                    "type": "import",
                    "name": str(code_chunk).strip(),
                    "chunk": code_chunk,
                    "file": file_path,
                    "start_line": start_line + 1,
                    "end_line": end_line,
                }
            )

    module_lines = [lines[i] for i in range(len(lines)) if i not in covered_lines and lines[i].strip() != ""]
    if module_lines:
        chunks.append(
            {
                "type": "module",
                "name": None,
                "chunk": "\n".join(module_lines),
                "file": file_path,
                "start_line": None,
                "end_line": None,
            }
        )

    return chunks


code_sample = '''
"""Module docstring. It does somethig"""

import os

# Module-level variable
x = 42

@decorator
def funct():
    """Function docstring."""
    # Function comment
    pass

class myclass:
    """Class docstring."""
    def method(self):
        pass
'''

final_chunks = chunk_python_file(code_sample, "sample.py")
for chunk in final_chunks:
    print(f"Type: {chunk['type']}")
    print(f"Name: {chunk['name']}")
    print(f"Chunk:\n{chunk['chunk']}")
    print("-" * 40)

# processed_files = 0
# for root, dirs, files in os.walk("blt"):
#     for file in files:
#         _, ext = os.path.splitext(file)
#         if ext in {".py"}:
#             full_path = os.path.join(root, file)
#             with open(full_path, "r", encoding="utf-8") as f:
#                 print(f"Processing file: {full_path}")
#                 content = f.read()
#             final_chunks = chunk_python_file(content, full_path)
#             for chunk in final_chunks:
#                 print(f"Type: {chunk['type']}")
#                 print(f"Name: {chunk['name']}")
#                 print(f"Chunk:\n{chunk['chunk']}")
#                 print("-" * 40)
#             processed_files += 1
#             if processed_files >= 5:
#                 break
#     if processed_files >= 5:
#         break

New: embed.py


Modified: pyproject.toml
@@ -69,6 +69,8 @@ pyzipper = "^0.3.6"
 tweepy = "^4.15.0"
 better-profanity = "^0.7.0"
 django-bleach = "^3.1.0"
+jsonschema = "^4.24.0"
+google-generativeai = "^0.8.5"
 
 
 [tool.poetry.group.dev.dependencies]

New: website/management/commands/ge.py
import ast
import json
import logging
import os

import google.generativeai as genai
from django.conf import settings
from django.core.management.base import BaseCommand

from website.views.aibot import get_gemini_api_key

logger = logging.getLogger(__name__)

REPO_PATH = settings.BASE_DIR
OUTPUT_FILE = os.path.join(REPO_PATH, "embeddings.json")

EXTENSIONS = {".py"}
GEMINI_API_KEY = get_gemini_api_key()
genai.configure(api_key=GEMINI_API_KEY)


def chunk_python_file(content: str, file_path: str):
    logger.info("Chunking file: %s", file_path)
    tree = ast.parse(content)
    lines = content.splitlines()
    chunks = []
    covered_lines = set()

    for node in ast.iter_child_nodes(tree):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
            if hasattr(node, "decorator_list") and node.decorator_list:
                decorator_lines = [decorator.lineno for decorator in node.decorator_list]
                start_line = min(decorator_lines) - 1
            else:
                start_line = node.lineno - 1
            end_line = node.end_lineno
            for i in range(start_line, end_line):
                covered_lines.add(i)
            code_chunk = "\n".join(lines[start_line:end_line])
            chunks.append(
                {
                    "type": "class" if isinstance(node, ast.ClassDef) else "function",
                    "name": getattr(node, "name", None),
                    "chunk": code_chunk,
                    "file": file_path,
                    "start_line": start_line + 1,
                    "end_line": end_line,
                }
            )
        elif isinstance(node, (ast.Import, ast.ImportFrom)):
            start_line = node.lineno - 1
            end_line = node.end_lineno if node.end_lineno else node.lineno
            for i in range(start_line, end_line):
                covered_lines.add(i)
            code_chunk = "\n".join(lines[start_line:end_line])
            chunks.append(
                {
                    "type": "import",
                    "name": str(code_chunk).strip(),
                    "chunk": code_chunk,
                    "file": file_path,
                    "start_line": start_line + 1,
                    "end_line": end_line,
                }
            )

    module_lines = [lines[i] for i in range(len(lines)) if i not in covered_lines and lines[i].strip() != ""]
    if module_lines:
        chunks.append(
            {
                "type": "module",
                "name": None,
                "chunk": "\n".join(module_lines),
                "file": file_path,
                "start_line": None,
                "end_line": None,
            }
        )

    return chunks


class Command(BaseCommand):
    help = "Generate embeddings of the repository."

    def handle(self, *args, **kwargs):
        logger.info("Generating repository embeddings. Using repository path: %s", REPO_PATH)
        logger.info("Output will be saved to: %s", OUTPUT_FILE)
        all_embeddings = []
        with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
            f.write("")
        try:
            processed_files = 0
            for root, dirs, files in os.walk(REPO_PATH):
                for file in files:
                    if processed_files >= 5:
                        break
                    _, ext = os.path.splitext(file)
                    if ext in EXTENSIONS:
                        full_path = os.path.join(root, file)
                        with open(full_path, "r", encoding="utf-8") as f:
                            content = f.read()
                        if not content.strip():
                            logger.warning("Skipping empty file: %s", full_path)
                            continue
                        chunks = chunk_python_file(content, full_path)
                        if not chunks:
                            logger.warning("No valid chunks found in file: %s", full_path)
                            continue
                        for chunk in chunks:
                            embedding = genai.embed_content(
                                model="models/text-embedding-004",
                                content=chunk["chunk"],
                                task_type="retrieval_document",
                                title=chunk["name"] or "Untitled",
                            )
                            if embedding:
                                all_embeddings.append(
                                    {
                                        "path:": full_path,
                                        "file_name": file,
                                        "content": chunk,
                                        "embedding": embedding["embedding"],
                                    }
                                )
                        processed_files += 1
                if processed_files >= 5:
                    break
        except Exception as e:
            self.stderr.write(f"Error generating embeddings: {e}")

        with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
            json.dump(all_embeddings, f, indent=4)

        self.stdout.write(f"Saved embeddings to {OUTPUT_FILE}")
        self.stdout.write(f"Total embedded chunks: {len(all_embeddings)}")

New: website/schemas/aibot_comment_schema.json
{
    "type": "object",
    "properties": {
        "action": {
            "type": "string",
            "enum": ["created", "edited", "deleted"]
        },
        "comment": {
            "type": "object",
            "properties": {
                "body": {
                    "type": "string",
                    "minLength": 1
                },
                "user": {
                    "type": "object",
                    "properties": {
                        "login": {
                            "type": "string"
                        },
                        "type": {
                            "type": "string",
                            "enum": [
                                "User"
                            ]
                        }
                    },
                    "required": [
                        "login",
                        "type"
                    ]
                }
            },
            "required": [
                "body",
                "user"
            ]
        },
        "issue": {
            "type": "object",
            "properties": {
                "pull_request": {
                    "type": "object"
                }
            }
        }
    },
    "required": [
        "action",
        "issue",
        "comment"
    ]
}

New: website/schemas/aibot_issue_schema.json
{
    "type": "object",
    "properties": {
        "action": {
            "type": "string",
            "enum": [
                "opened",
                "edited"
            ]
        },
        "issue": {
            "type": "object",
            "properties": {
                "number": {
                    "type": "integer",
                    "minimum": 1
                },
                "title": {
                    "type": "string",
                    "minLength": 1
                },
                "body": {
                    "type": [
                        "string",
                        "null"
                    ],
                    "default": null
                },
                "user": {
                    "type": "object",
                    "properties": {
                        "login": {
                            "type": "string"
                        },
                        "type": {
                            "type": "string",
                            "enum": [
                                "User"
                            ]
                        }
                    },
                    "required": [
                        "login",
                        "type"
                    ]
                }
            },
            "required": [
                "number",
                "title",
                "user"
            ]
        },
        "changes": {
            "type": "object",
            "properties": {
                "title": {
                    "type": "object",
                    "properties": {
                        "from": {
                            "type": "string"
                        }
                    },
                    "required": [
                        "from"
                    ]
                },
                "body": {
                    "type": "object",
                    "properties": {
                        "from": {
                            "type": "string"
                        }
                    },
                    "required": [
                        "from"
                    ]
                }
            }
        }
    },
    "required": [
        "action",
        "issue"
    ]
}

New: website/schemas/aibot_pr_schema.json
{
    "type": "object",
    "properties": {
        "action": {
            "type": "string",
            "enum": [
                "opened",
                "synchronized"
            ]
        },
        "pull_request": {
            "type": "object",
            "properties": {
                "number": {
                    "type": "integer",
                    "minimum": 1
                },
                "title": {
                    "type": "string",
                    "minLength": 1
                },
                "body": {
                    "type": [
                        "string",
                        "null"
                    ],
                    "default": null
                },
                "commits": {
                    "type": "integer",
                    "minimum": 1
                },
                "changed_files": {
                    "type": "integer",
                    "minimum": 1
                },
                "diff_url": {
                    "type": "string",
                    "format": "uri"
                },
                "patch_url": {
                    "type": "string",
                    "format": "uri"
                },
                "user": {
                    "type": "object",
                    "properties": {
                        "login": {
                            "type": "string"
                        },
                        "type": {
                            "type": "string",
                            "enum": [
                                "User"
                            ]
                        }
                    },
                    "required": [
                        "login",
                        "type"
                    ]
                }
            },
            "required": [
                "number",
                "title",
                "commits",
                "changed_files",
                "diff_url",
                "patch_url",
                "user"
            ]
        }
    },
    "required": [
        "action",
        "pull_request"
    ]
}

Modified: website/templates/status_page.html
@@ -1,24 +1,20 @@
-{% extends "base.html" %}
+{% extends 'base.html' %}
 {% load static %}
 {% load custom_tags %}
 {% load humanize %}
-{% block title %}
-    Service Status
-{% endblock title %}
+{% block title %}Service Status{% endblock %}
 {% block description %}
     Check the status of various services including Bitcoin Node, SendGrid API, and GitHub API. Stay informed about their current operational status and block information.
-{% endblock description %}
+{% endblock %}
 {% block keywords %}
     Service Status, Bitcoin Node, SendGrid API, GitHub API, Operational Status, Block Information
-{% endblock keywords %}
-{% block og_title %}
-    Service Status - Monitor Operational Status
-{% endblock og_title %}
+{% endblock %}
+{% block og_title %}Service Status - Monitor Operational Status{% endblock %}
 {% block og_description %}
     View the current status of services such as Bitcoin Node, SendGrid API, and GitHub API. Stay updated on their operational status and block information.
-{% endblock og_description %}
+{% endblock %}
 {% block content %}
-    {% include "includes/sidenav.html" %}
+    {% include 'includes/sidenav.html' %}
     <div class="max-w-7xl mx-auto px-4 py-8">
         <h1 class="text-3xl font-bold text-center mb-8">Service Status</h1>
         <a href="{% url 'management_commands' %}"
@@ -30,7 +26,7 @@ <h1 class="text-3xl font-bold text-center mb-8">Service Status</h1>
                 <div class="bg-white rounded-lg shadow-sm p-6 border border-[#e74c3c]">
                     <h3 class="text-xl font-semibold mb-4">Bitcoin Node</h3>
                     <div class="flex items-center">
-                        <div class="w-3 h-3 rounded-full mr-3 {% if status.bitcoin == None %}bg-gray-400{% elif status.bitcoin %}bg-green-500{% else %}bg-red-500{% endif %}">
+                        <div class="w-3 h-3 rounded-full mr-3 {% if status.bitcoin == None %}  bg-gray-400  {% elif status.bitcoin %}  bg-green-500  {% else %}  bg-red-500  {% endif %}">
                         </div>
                         {% if status.bitcoin == None %}
                             <span>Status Unknown</span>
@@ -51,7 +47,7 @@ <h3 class="text-xl font-semibold mb-4">Bitcoin Node</h3>
                 <div class="bg-white rounded-lg shadow-sm p-6 border border-[#e74c3c]">
                     <h3 class="text-xl font-semibold mb-4">SendGrid API</h3>
                     <div class="flex items-center">
-                        <div class="w-3 h-3 rounded-full mr-3 {% if status.sendgrid == None %}bg-gray-400{% elif status.sendgrid %}bg-green-500{% else %}bg-red-500{% endif %}">
+                        <div class="w-3 h-3 rounded-full mr-3 {% if status.sendgrid == None %}  bg-gray-400  {% elif status.sendgrid %}  bg-green-500  {% else %}  bg-red-500  {% endif %}">
                         </div>
                         {% if status.sendgrid == None %}
                             <span>Status Unknown</span>
@@ -66,7 +62,7 @@ <h3 class="text-xl font-semibold mb-4">SendGrid API</h3>
                 <div class="bg-white rounded-lg shadow-sm p-6 border border-[#e74c3c]">
                     <h3 class="text-xl font-semibold mb-4">OpenAI API</h3>
                     <div class="flex items-center">
-                        <div class="w-3 h-3 rounded-full mr-3 {% if status.openai == None %}bg-gray-400{% elif status.openai %}bg-green-500{% else %}bg-red-500{% endif %}">
+                        <div class="w-3 h-3 rounded-full mr-3 {% if status.openai == None %}  bg-gray-400  {% elif status.openai %}  bg-green-500  {% else %}  bg-red-500  {% endif %}">
                         </div>
                         {% if status.openai == None %}
                             <span>Status Unknown</span>
@@ -81,7 +77,7 @@ <h3 class="text-xl font-semibold mb-4">OpenAI API</h3>
                 <div class="bg-white rounded-lg shadow-sm p-6 border border-[#e74c3c]">
                     <h3 class="text-xl font-semibold mb-4">GitHub API</h3>
                     <div class="flex items-center mb-4">
-                        <div class="w-3 h-3 rounded-full mr-3 {% if status.github == None %}bg-gray-400{% elif status.github %}bg-green-500{% else %}bg-red-500{% endif %}">
+                        <div class="w-3 h-3 rounded-full mr-3 {% if status.github == None %}  bg-gray-400  {% elif status.github %}  bg-green-500  {% else %}  bg-red-500  {% endif %}">
                         </div>
                         {% if status.github == None %}
                             <span>Status Unknown</span>
@@ -206,7 +202,7 @@ <h3 class="text-xl font-semibold mb-4">Redis Stats</h3>
                     <div>
                         <p class="mb-2">
                             <strong>Status:</strong>
-                            <span class="{% if status.redis_stats.status == 'Connected' %}text-green-600{% else %}text-red-600{% endif %}">
+                            <span class="{% if status.redis_stats.status == 'Connected' %}  text-green-600  {% else %}  text-red-600  {% endif %}">
                                 {{ status.redis_stats.status }}
                             </span>
                         </p>
@@ -233,6 +229,31 @@ <h3 class="text-xl font-semibold mb-4">Redis Stats</h3>
                         {% endif %}
                     </div>
                 </div>
+                <div class="bg-white rounded-lg shadow-sm p-6 border border-[#e74c3c]">
+                    <h3 class="text-xl font-semibold mb-4">AI Bot Webhook Status</h3>
+                    <div>
+                        <p class="mb-2">
+                            <strong>Status:</strong>
+                            <span class="{% if status.github_aibot_webhook.health == '1' %}  text-green-600  {% elif status.github_aibot_webhook.health == '2' %}  text-yellow-600  {% else %}  text-red-600  {% endif %}">
+                                {{ status.github_aibot_webhook.status }}
+                            </span>
+                        </p>
+                        {% if status.github_aibot_webhook.health == '0' %}
+                            <div class="text-red-600 mb-2">
+                                <p>
+                                    <strong>Error:</strong> Webhook ping failed
+                                </p>
+                            </div>
+                        {% endif %}
+                        {% if status.github_aibot_webhook.health == '3' %}
+                            <div class="text-red-600 mb-2">
+                                <p>
+                                    <strong>Configuration Error:</strong> Missing required settings
+                                </p>
+                            </div>
+                        {% endif %}
+                    </div>
+                </div>
             </div>
             <!-- Slack Bot Activity Column -->
             <div>
@@ -289,11 +310,12 @@ <h4 class="text-lg font-semibold mb-4">Recent Activities</h4>
                                         {% for activity in status.slack_bot.recent_activities %}
                                             <tr class="hover:bg-gray-50">
                                                 <td class="px-6 py-4 whitespace-nowrap text-sm">{{ activity.activity_type|title }}</td>
-                                                <td class="px-6 py-4 whitespace-nowrap text-sm">{{ activity.created|date:"M d, H:i" }}</td>
+                                                <td class="px-6 py-4 whitespace-nowrap text-sm">{{ activity.created|date:'M d, H:i' }}</td>
                                                 <td class="px-6 py-4 whitespace-nowrap text-sm">
                                                     <span class="inline-flex items-center">
-                                                        <div class="w-2 h-2 rounded-full mr-2 {% if activity.success %}bg-green-500{% else %}bg-red-500{% endif %}"></div>
-                                                        {{ activity.success|yesno:"Success,Failed" }}
+                                                        <div class="w-2 h-2 rounded-full mr-2 {% if activity.success %}  bg-green-500  {% else %}  bg-red-500  {% endif %}">
+                                                        </div>
+                                                        {{ activity.success|yesno:'Success,Failed' }}
                                                     </span>
                                                 </td>
                                             </tr>
@@ -307,126 +329,126 @@ <h4 class="text-lg font-semibold mb-4">Recent Activities</h4>
             </div>
         </div>
     </div>
-{% endblock content %}
+{% endblock %}
 {% block extra_js %}
     <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
     <script>
-document.addEventListener('DOMContentLoaded', function() {
-    const ctx = document.getElementById('activityChart').getContext('2d');
-    const dates = JSON.parse('{{ status.template_chart_data.dates|escapejs }}');
-    const teamJoins = JSON.parse('{{ status.template_chart_data.team_joins|escapejs }}');
-    const commands = JSON.parse('{{ status.template_chart_data.commands|escapejs }}');
-
-    const chart = new Chart(ctx, {
+    document.addEventListener('DOMContentLoaded', function () {
+      const ctx = document.getElementById('activityChart').getContext('2d')
+      const dates = JSON.parse('{{ status.template_chart_data.dates|escapejs }}')
+      const teamJoins = JSON.parse('{{ status.template_chart_data.team_joins|escapejs }}')
+      const commands = JSON.parse('{{ status.template_chart_data.commands|escapejs }}')
+    
+      const chart = new Chart(ctx, {
         type: 'bar',
         data: {
-            labels: dates,
-            datasets: [
-                {
-                    label: 'Team Joins',
-                    data: teamJoins,
-                    backgroundColor: '#e74c3c',
-                    borderColor: '#c0392b',
-                    borderWidth: 1
-                },
-                {
-                    label: 'Commands',
-                    data: commands,
-                    backgroundColor: '#e74c3c80',
-                    borderColor: '#c0392b80',
-                    borderWidth: 1
-                }
-            ]
+          labels: dates,
+          datasets: [
+            {
+              label: 'Team Joins',
+              data: teamJoins,
+              backgroundColor: '#e74c3c',
+              borderColor: '#c0392b',
+              borderWidth: 1
+            },
+            {
+              label: 'Commands',
+              data: commands,
+              backgroundColor: '#e74c3c80',
+              borderColor: '#c0392b80',
+              borderWidth: 1
+            }
+          ]
         },
         options: {
-            responsive: true,
-            maintainAspectRatio: false,
-            scales: {
-                y: {
-                    beginAtZero: true
-                }
+          responsive: true,
+          maintainAspectRatio: false,
+          scales: {
+            y: {
+              beginAtZero: true
             }
+          }
         }
-    });
+      })
     
-    // GitHub API Usage History Chart
-    const githubApiChartElement = document.getElementById('githubApiChart');
-    if (githubApiChartElement) {
-        let githubApiHistory = [];
+      // GitHub API Usage History Chart
+      const githubApiChartElement = document.getElementById('githubApiChart')
+      if (githubApiChartElement) {
+        let githubApiHistory = []
         try {
-            githubApiHistory = JSON.parse('{{ status.github_api_history|escapejs|default:"[]" }}');
+          githubApiHistory = JSON.parse('{{ status.github_api_history|escapejs|default:"[]" }}')
         } catch (e) {
-            console.error('Error parsing GitHub API history:', e);
+          console.error('Error parsing GitHub API history:', e)
         }
-        
+    
         if (githubApiHistory && githubApiHistory.length > 0) {
-            // Format the data for the chart
-            const timestamps = githubApiHistory.map(entry => entry.timestamp);
-            const remaining = githubApiHistory.map(entry => parseInt(entry.remaining) || 0);
-            const used = githubApiHistory.map(entry => parseInt(entry.used) || 0);
-            
-            new Chart(githubApiChartElement, {
-                type: 'line',
-                data: {
-                    labels: timestamps,
-                    datasets: [
-                        {
-                            label: 'Remaining',
-                            data: remaining,
-                            backgroundColor: 'rgba(231, 76, 60, 0.2)',
-                            borderColor: '#e74c3c',
-                            borderWidth: 2,
-                            tension: 0.1,
-                            fill: true
-                        },
-                        {
-                            label: 'Used',
-                            data: used,
-                            backgroundColor: 'rgba(52, 152, 219, 0.2)',
-                            borderColor: '#3498db',
-                            borderWidth: 2,
-                            tension: 0.1,
-                            fill: true
-                        }
-                    ]
+          // Format the data for the chart
+          const timestamps = githubApiHistory.map((entry) => entry.timestamp)
+          const remaining = githubApiHistory.map((entry) => parseInt(entry.remaining) || 0)
+          const used = githubApiHistory.map((entry) => parseInt(entry.used) || 0)
+    
+          new Chart(githubApiChartElement, {
+            type: 'line',
+            data: {
+              labels: timestamps,
+              datasets: [
+                {
+                  label: 'Remaining',
+                  data: remaining,
+                  backgroundColor: 'rgba(231, 76, 60, 0.2)',
+                  borderColor: '#e74c3c',
+                  borderWidth: 2,
+                  tension: 0.1,
+                  fill: true
                 },
-                options: {
-                    responsive: true,
-                    maintainAspectRatio: false,
-                    scales: {
-                        y: {
-                            beginAtZero: true,
-                            title: {
-                                display: true,
-                                text: 'API Calls'
-                            }
-                        },
-                        x: {
-                            title: {
-                                display: true,
-                                text: 'Time'
-                            }
-                        }
-                    },
-                    plugins: {
-                        title: {
-                            display: true,
-                            text: 'GitHub API Usage History'
-                        },
-                        tooltip: {
-                            callbacks: {
-                                label: function(context) {
-                                    const label = context.dataset.label || '';
-                                    const value = context.parsed.y;
-                                    return `${label}: ${value}`;
-                                }
-                            }
-                        }
+                {
+                  label: 'Used',
+                  data: used,
+                  backgroundColor: 'rgba(52, 152, 219, 0.2)',
+                  borderColor: '#3498db',
+                  borderWidth: 2,
+                  tension: 0.1,
+                  fill: true
+                }
+              ]
+            },
+            options: {
+              responsive: true,
+              maintainAspectRatio: false,
+              scales: {
+                y: {
+                  beginAtZero: true,
+                  title: {
+                    display: true,
+                    text: 'API Calls'
+                  }
+                },
+                x: {
+                  title: {
+                    display: true,
+                    text: 'Time'
+                  }
+                }
+              },
+              plugins: {
+                title: {
+                  display: true,
+                  text: 'GitHub API Usage History'
+                },
+                tooltip: {
+                  callbacks: {
+                    label: function (context) {
+                      const label = context.dataset.label || ''
+                      const value = context.parsed.y
+                      return `${label}: ${value}`
                     }
+                  }
                 }
-            });
+              }
+            }
+          })
         }
-    }
-});
+      }
+    })
     </script>
-{% endblock extra_js %}
+{% endblock %}

New: website/test_aibot.py
import json
from unittest.mock import patch

from django.test import TestCase, override_settings
from django.urls import reverse


@override_settings(GITHUB_AIBOT_WEBHOOK_SECRET="test_secret")
@override_settings(LOGGING={"version": 1, "disable_existing_loggers": True})
class MainGitHubWebhookDispatcherTests(TestCase):
    def setUp(self):
        self.url = reverse("main_github_aibot_webhook_dispatcher")
        self.valid_headers = {
            "X-GitHub-Event": "ping",
            "X-Hub-Signature-256": "sha256=valid_signature",
            "Content-Type": "application/json",
        }
        self.valid_body = json.dumps({"zen": "Test message"})

    def test_invalid_http_method(self):
        """Test GET request rejection (non POST request) )"""
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 400)
        self.assertIn("Only POST requests", response.content.decode())

    def test_missing_signature(self):
        """Test signature verification"""
        invalid_headers = self.valid_headers.copy()
        del invalid_headers["X-Hub-Signature-256"]
        invalid_headers["X-GitHub-Event"] = "pull_request"
        response = self.client.post(
            self.url, data=self.valid_body, headers=invalid_headers, content_type="application/json"
        )
        self.assertEqual(response.status_code, 403)
        self.assertIn("Missing webhook signature header", response.json()["error"])

    def test_invalid_signature(self):
        """Test invalid signature handling"""
        invalid_headers = self.valid_headers.copy()
        invalid_headers["X-Hub-Signature-256"] = "sha256=invalid_signature"
        invalid_headers["X-GitHub-Event"] = "pull_request"
        response = self.client.post(
            self.url, data=self.valid_body, headers=invalid_headers, content_type="application/json"
        )
        self.assertEqual(response.status_code, 403)
        self.assertIn("Invalid webhook signature", response.json()["error"])

    def test_empty_request_body(self):
        """Test empty request body handling"""
        response = self.client.post(self.url, data="", headers=self.valid_headers, content_type="application/json")
        self.assertEqual(response.status_code, 400)
        self.assertIn("Empty request body", response.json()["error"])

    def test_invalid_json(self):
        """Test malformed JSON handling"""
        response = self.client.post(
            self.url, data="INVALID_JSON", headers=self.valid_headers, content_type="application/json"
        )
        self.assertEqual(response.status_code, 400)
        self.assertIn("Invalid JSON payload", response.json()["error"])

    @patch("website.views.aibot.verify_github_signature", return_value=True)
    def test_missing_event_header(self, mock_verify_signature):
        """Test missing event header handling"""
        headers = self.valid_headers.copy()
        del headers["X-GitHub-Event"]
        response = self.client.post(self.url, data=self.valid_body, headers=headers, content_type="application/json")
        self.assertEqual(response.status_code, 400)
        self.assertIn("Missing X-GitHub-Event header", response.json()["error"])

    @patch("website.views.aibot.verify_github_signature", return_value=True)
    def test_valid_ping_event(self, mock_verify_signature):
        """Test path for ping event"""
        response = self.client.post(
            self.url, data=self.valid_body, headers=self.valid_headers, content_type="application/json"
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.json(), {"status": "pong", "zen": "Test message"})

    @patch("website.views.aibot.verify_github_signature", return_value=True)
    @patch("website.views.aibot.handle_pull_request_event", side_effect=Exception("Test message"))
    def test_generic_error_during_event_handling(self, mock_handler, mock_verify_signature):
        """Test path for a generic error raised during event handling"""
        headers = self.valid_headers.copy()
        headers["X-GitHub-Event"] = "pull_request"
        response = self.client.post(self.url, data=self.valid_body, headers=headers, content_type="application/json")
        self.assertEqual(response.status_code, 500)
        self.assertIn("Unexpected error", response.json()["error"])

    @patch("website.views.aibot.verify_github_signature", return_value=True)
    @patch("website.views.aibot.handle_pull_request_event")
    def test_valid_pull_request_event(self, mock_handler, mock_verify_signature):
        """Test path for pull request event"""
        headers = self.valid_headers.copy()
        headers["X-GitHub-Event"] = "pull_request"
        response = self.client.post(self.url, data=self.valid_body, headers=headers, content_type="application/json")
        self.assertEqual(response.status_code, 200)
        mock_handler.assert_called_once()
        self.assertIn("Pull request event processed", response.json()["status"])

    @patch("website.views.aibot.verify_github_signature", return_value=True)
    @patch("website.views.aibot.handle_comment_event")
    def test_valid_comment_event(self, mock_handler, mock_verify_signature):
        """Test path for issue comment event"""
        headers = self.valid_headers.copy()
        headers["X-GitHub-Event"] = "issue_comment"
        response = self.client.post(self.url, data=self.valid_body, headers=headers, content_type="application/json")
        self.assertEqual(response.status_code, 200)
        mock_handler.assert_called_once()
        self.assertIn("Comment event processed", response.json()["status"])

    @patch("website.views.aibot.verify_github_signature", return_value=True)
    @patch("website.views.aibot.handle_issue_event")
    def test_valid_issue_event(self, mock_handler, mock_verify_signature):
        """Test path for issue event"""
        headers = self.valid_headers.copy()
        headers["X-GitHub-Event"] = "issues"
        response = self.client.post(self.url, data=self.valid_body, headers=headers, content_type="application/json")
        self.assertEqual(response.status_code, 200)
        mock_handler.assert_called_once()
        self.assertIn("Issue event processed", response.json()["status"])

New: website/views/aibot.py
"""This module handles the GitHub AI Bot webhook events and interactions.
It processes pull requests, issues, and comments, and interacts with the Gemini AI API to generate responses and post them on github.
"""

import hashlib
import hmac
import json
import logging
import random
import time
from typing import Any, Dict, Optional

import google.generativeai as genai
import requests
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.http import HttpRequest, JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_GET
from jsonschema import ValidationError, validate

logger = logging.getLogger(__name__)

MAX_RETRIES = 5
RETRY_BACKOFF = 2

try:
    with open("website/schemas/aibot_comment_schema.json", "r", encoding="utf-8") as f:
        AIBOT_COMMENT_SCHEMA = json.load(f)
    with open("website/schemas/aibot_issue_schema.json", "r", encoding="utf-8") as f:
        AIBOT_ISSUE_SCHEMA = json.load(f)
    with open("website/schemas/aibot_pr_schema.json", "r", encoding="utf-8") as f:
        AIBOT_PR_SCHEMA = json.load(f)
except (FileNotFoundError, json.JSONDecodeError) as e:
    logger.error("Failed to load schema files: %s", str(e))


def _get_setting(key_name: str) -> str:
    """
    Retrieve a required setting value by its key name from Django settings.

    Args:
        key_name: The name of the setting to retrieve.

    Returns:
        The value of the setting.

    Raises:
        ImproperlyConfigured: If the setting is missing or empty.
    """
    value = getattr(settings, key_name, None)
    if not value:
        raise ImproperlyConfigured(f"[CONFIG ERROR] Setting '{key_name}' is missing or empty.")
    return value


def get_gemini_api_key() -> Optional[str]:
    """Retrieve the Gemini API key from settings."""
    return _get_setting("GEMINI_API_KEY")


def get_github_token() -> Optional[str]:
    """Retrieve the GitHub token from settings."""
    return _get_setting("GITHUB_TOKEN")


def get_github_url() -> Optional[str]:
    """Retrieve the GitHub URL from settings."""
    return _get_setting("GITHUB_URL")


def get_github_api_url() -> Optional[str]:
    """Retrieve the GitHub API URL from settings."""
    return _get_setting("GITHUB_API_URL")


def get_github_aibot_webhook_url() -> Optional[str]:
    """Retrieve the GitHub AI bot webhook URL from settings."""
    return _get_setting("GITHUB_AIBOT_WEBHOOK_URL")


def get_github_aibot_webhook_id() -> Optional[str]:
    """Retrieve the GitHub AI bot webhook ID from settings."""
    return _get_setting("GITHUB_AIBOT_WEBHOOK_ID")


def get_github_aibot_webhook_secret() -> Optional[str]:
    """Retrieve the GitHub AI bot webhook secret from settings."""
    return _get_setting("GITHUB_AIBOT_WEBHOOK_SECRET")


def get_github_aibot_token() -> Optional[str]:
    """Retrieve the GitHub AI bot token from settings."""
    return _get_setting("GITHUB_AIBOT_TOKEN")


def get_github_aibot_username() -> Optional[str]:
    """Retrieve the GitHub AI bot username from settings."""
    return _get_setting("GITHUB_AIBOT_APP_NAME")


def get_aibot_pr_analysis_comment_marker() -> str:
    """
    Returns the marker used in PR analysis comments to identify them as AI Bot generated.
    This is used to differentiate AI Bot comments from user comments.
    """
    return f"**PR Analysis by {get_github_aibot_username()}**"


def get_aibot_issue_analysis_comment_marker() -> str:
    """
    Returns the marker used in issue analysis comments to identify them as AI Bot generated.
    This is used to differentiate AI Bot comments from user comments.
    """
    return f"**Issue Analysis by {get_github_aibot_username()}**"


def _generate_response(prompt: str, model: str = "gemini-2.0-flash") -> Optional[str]:
    """
    Generate a text response from the Gemini model with robust error handling and retry logic.

    Args:
        prompt (str): Input prompt for the AI model
        model (str): Which Gemini model to use (default: 'gemini-2.0-flash')

    Returns:
        Optional[str]: Generated text if successful, None if failed after retries

    Raises:
        ValueError: If prompt is empty or invalid
    """
    if not prompt or not isinstance(prompt, str):
        raise ValueError("Prompt must be a non-empty string")

    try:
        genai.configure(api_key=get_gemini_api_key())
        model_instance = genai.GenerativeModel(model)
    except Exception as e:
        logger.error("Failed to configure Gemini: %s", str(e))
        return None

    for attempt in range(1, MAX_RETRIES + 1):
        try:
            logger.info("Generating response (attempt %d/%d)", attempt, MAX_RETRIES)

            response = model_instance.generate_content(prompt)

            if not response.text:
                raise ValueError("Empty response from model")

            logger.debug("Successfully generated AI response")
            return response.text

        except (genai.APIError, requests.exceptions.RequestException) as e:
            if "API key" in str(e):
                logger.error("Authentication failed - check API key")
                return None

            logger.warning("API error on attempt %d: %s", attempt, str(e))

        except Exception as e:
            logger.error("Unexpected error: %s", str(e))
            if attempt == MAX_RETRIES:
                logger.error("Final attempt failed for prompt: %.50s...", prompt)
                return None

        if attempt < MAX_RETRIES:
            wait_time = RETRY_BACKOFF * (2 ** (attempt - 1)) + random.uniform(0, 1)
            logger.info("Retrying in %.1fs...", wait_time)
            time.sleep(wait_time)

    return None


@require_GET
def aibot_webhook_is_healthy(request: HttpRequest) -> JsonResponse:
    """
    Full health check that ensures:
    1. Django server is up
    2. GitHub webhook endpoint is reachable
    3. Webhook delivery actually works by sending a test payload

    Returns:
        JsonResponse with basic status information
    """
    required_settings = ["GITHUB_TOKEN", "GITHUB_AIBOT_WEBHOOK_ID", "GITHUB_API_URL", "GITHUB_AIBOT_WEBHOOK_URL"]

    missing_settings = [s for s in required_settings if not getattr(settings, s, None)]
    if missing_settings:
        logger.error("Configuration error - Missing settings: %s", missing_settings)
        return JsonResponse(
            {"health": "3", "status": "Configuration error", "message": "Required settings are missing"}, status=500
        )

    github_token = get_github_token()
    webhook_id = get_github_aibot_webhook_id()
    repo_api_url = get_github_api_url().rstrip("/")
    webhook_url = get_github_aibot_webhook_url()

    try:
        ping_url = f"{repo_api_url}/hooks/{webhook_id}/pings"
        headers = {
            "Authorization": f"Bearer {github_token}",
            "Accept": "application/vnd.github.v3+json",
        }

        logger.info("Attempting to ping GitHub webhook at %s", ping_url)
        ping_response = requests.post(ping_url, headers=headers, timeout=5)

        if ping_response.status_code != 204:
            logger.error(
                "Webhook ping failed. Status: %s, Response: %s",
                ping_response.status_code,
                ping_response.text,
            )
            return JsonResponse(
                {"health": "0", "status": "Webhook ping failed", "message": "Could not verify webhook connectivity"},
                status=500,
            )

        test_payload = {"test": "webhook_health_check"}
        test_headers = {"X-GitHub-Event": "ping", "Content-Type": "application/json"}
        logger.info("Testing webhook delivery to %s", webhook_url)
        delivery_response = requests.post(webhook_url, json=test_payload, headers=test_headers, timeout=5)

        if delivery_response.status_code != 200:
            logger.error(
                "Webhook delivery failed. Status: %s, Response: %s",
                delivery_response.status_code,
                delivery_response.text,
            )
            return JsonResponse(
                {"health": "0", "status": "Webhook delivery failed", "message": "Could not verify webhook delivery"},
                status=500,
            )
        logger.info("Webhook health check successful. Response from delivery: %s", delivery_response.json())
        return JsonResponse(
            {
                "health": "1",
                "status": "Webhook is reachable and delivery works",
                "repo": get_github_url(),
            }
        )
    except requests.RequestException as e:
        logger.error("Request error during webhook health check: %s", str(e), exc_info=True)
        return JsonResponse(
            {
                "health": "2",
                "status": "Error contacting GitHub API or webhook endpoint",
                "message": "Network communication error",
            },
            status=500,
        )
    except ValidationError as ve:
        logger.error("Validation error during webhook health check: %s", str(ve), exc_info=True)
        return JsonResponse(
            {"health": "2", "status": "Validation error", "message": "Error during request validation"},
            status=400,
        )
    except Exception as e:
        logger.error("Unexpected error during webhook health check: %s", str(e), exc_info=True)
        return JsonResponse(
            {"health": "2", "status": "Unexpected error during health check", "message": "Internal server error"},
            status=500,
        )


@csrf_exempt
def main_github_aibot_webhook_dispatcher(request: HttpRequest) -> JsonResponse:
    """
    Main entry point for handling GitHub webhook events.

    This function routes different GitHub webhook events to their respective handlers
    based on the event type and action. Supported events include:
    - Pull Request events (opened, synchronize)
    - Issue comments (bot mentions in PRs or issues)
    - Issue events (opened, mentioned)

    Args:
        request: The incoming HTTP request from GitHub webhook

    Returns:
        JsonResponse: A response indicating the webhook was received successfully,
                      or an error response if the request is in.

    Raises:
        Status 400: If the request method is not POST, request body is empty or JSON is invalid
        Status 403: If the webhook signature verification fails
    """
    if request.method != "POST":
        logger.warning("Invalid request method: %s. Only POST requests are accepted.", request.method)
        return JsonResponse({"error": "Invalid method: Only POST requests are accepted"}, status=400)

    if not request.body:
        logger.warning("Request body is empty.")
        return JsonResponse({"error": "Empty request body received."}, status=400)

    try:
        payload: Dict[str, Any] = json.loads(request.body)
    except json.JSONDecodeError:
        logger.error("Invalid JSON payload received")
        return JsonResponse({"error": "Invalid JSON payload"}, status=400)

    event_type = request.headers.get("X-GitHub-Event", None)
    if not event_type:
        logger.warning("Missing X-GitHub-Event header.")
        return JsonResponse({"error": "Missing X-GitHub-Event header."}, status=400)

    logger.info("Webhook received - Event: %s, Action: %s", event_type, payload.get("action", "unknown"))
    if event_type == "ping":
        zen = payload.get("zen", "No zen message received.")
        logger.info("Webhook ping received: %s", zen)
        return JsonResponse({"status": "pong", "zen": zen}, status=200)

    signature_header = request.headers.get("X-Hub-Signature-256", None)
    if not signature_header:
        logger.warning("Missing signature header in the request.")
        return JsonResponse({"error": "Missing webhook signature header."}, status=403)

    webhook_secret = get_github_aibot_webhook_secret()
    if not verify_github_signature(webhook_secret, request.body, signature_header):
        logger.warning("Invalid webhook signature received for the Github AIbot webhook.")
        return JsonResponse({"error": "Invalid webhook signature."}, status=403)

    try:
        if event_type == "pull_request":
            logger.info("Processing pull request event")
            handle_pull_request_event(payload)
            return JsonResponse({"status": "Pull request event processed"}, status=200)

        if event_type == "issue_comment":
            logger.info("Processing issue comment event")
            handle_comment_event(payload)
            return JsonResponse({"status": "Comment event processed"}, status=200)

        if event_type == "issues":
            logger.info("Processing issue event")
            handle_issue_event(payload)
            return JsonResponse({"status": "Issue event processed"}, status=200)

        logger.info("Ignoring unsupported event type: %s", event_type)
        return JsonResponse({"status": "Unsupported event type - ignored"})
    except Exception as e:
        logger.error("Unexpected error occurred while processing the webhook request: %s", str(e), exc_info=True)
        return JsonResponse({"error": "Unexpected error occurred while processing the webhook request"}, status=500)


def handle_pull_request_event(payload: Dict[str, Any]) -> JsonResponse:
    """Validate and handle pull request related events (opened, synchronize)."""
    validate_payload_schema(payload, AIBOT_PR_SCHEMA)
    action = payload.get("action")
    pr_data = payload.get("pull_request", {})
    if action == "opened":
        logger.info("New PR opened: #%s - %s", pr_data.get("number"), pr_data.get("title"))
        aibot_handle_new_pr_opened(payload)
    elif action == "synchronize":
        logger.info("PR updated: #%s - New commits pushed", pr_data.get("number"))
        aibot_handle_pr_update(payload)
    return JsonResponse({"status": "PR event processed"})


def handle_comment_event(payload: Dict[str, Any]) -> None:
    """
    Validate and handle comments on PRs/issues where the bot might be mentioned.
    Ignores comments made by the bot itself (present in the validation schema).
    """
    validate_payload_schema(payload, AIBOT_COMMENT_SCHEMA)
    comment = payload.get("comment", {})
    comment_body = comment.get("body", "").lower()

    logger.info(
        "Processing comment event:\n- Comment ID: %s\n- Body: %s\n- User: %s",
        comment.get("id"),
        comment_body[:50],
        comment.get("user", {}).get("login", "unknown"),
    )

    if comment.get("user", {}).get("login") == get_github_aibot_username():
        logger.info("Ignoring comment made by the AI Bot itself.")
        return

    if f"@{get_github_aibot_username()}" in comment_body:
        issue = payload.get("issue", {})
        if "pull_request" in issue:
            logger.info("Bot mentioned in PR comment - analyzing...")
            aibot_handle_pr_comment(payload)
        else:
            logger.info("Bot mentioned in issue comment - analyzing...")
            aibot_handle_issue_comment(payload)
    else:
        logger.info("Comment does not mention the bot. Ignoring.")


def handle_issue_event(payload: Dict[str, Any]) -> JsonResponse:
    """Handle issue related events (opened, edited)."""
    validate_payload_schema(payload, AIBOT_ISSUE_SCHEMA)
    action = payload.get("action")
    issue_data = payload.get("issue", {})
    if action == "opened":
        logger.info("New issue opened: #%s - %s", issue_data.get("number"), issue_data.get("title"))
        aibot_handle_new_issue(payload)
    elif action == "edited":
        logger.info("Issue edited: #%s - %s", issue_data.get("number"), issue_data.get("title"))
        aibot_handle_issue_edited(payload)
    return JsonResponse({"status": "Issue event processed"})


def aibot_handle_new_pr_opened(payload: Dict[str, Any]) -> None:
    """This function handles the logic when a new PR is opened."""
    logger.info("Handling new PR opened.")
    pr = payload.get("pull_request", {})
    pr_number = pr.get("number")
    pr_title = pr.get("title", "No title")
    pr_body = pr.get("body", "No body")

    context = f"PR Title: {pr_title}\nPR Body: {pr_body}\n"

    pr_diff = _fetch_pr_diff(pr_number)
    if pr_diff:
        cleaned_diff = _clean_diff(pr_diff)
        context += f"PR Diff:\n{cleaned_diff}...\n"
    else:
        context += "PR Diff: Unable to fetch diff.\n"

    prompt = (
        f"{context}\n"
        "You are an experienced open source reviewer. Please provide a concise, constructive review of this pull request. "
        "Highlight any strengths, potential issues, and suggest improvements if needed. "
        "Be friendly and professional."
    )

    logger.info("Context for AI Bot: %s", prompt)
    ai_response = _generate_response(context)
    if not ai_response:
        logger.error("Failed to generate AI response for new PR.")
        return

    logger.info("Generated AI response for new PR: %s", ai_response)

    ai_response = f"{get_aibot_pr_analysis_comment_marker()}\n{ai_response}"

    response = post_or_patch_github_comment(pr_number, ai_response)
    if response and response.status_code == 201:
        logger.info("AI Bot response posted successfully: %s", ai_response)
    else:
        logger.error("Failed to post AI Bot response. Response: %s", getattr(response, "text", "No response"))


def aibot_handle_pr_update(payload: Dict[str, Any]) -> None:
    """This function handles the logic when a PR is updated with new commits."""
    logger.info("Handling PR update.")
    pr = payload.get("pull_request", {})
    pr_number = pr.get("number")
    pr_title = pr.get("title", "No title")

    context = f"PR Title: {pr_title}\n"

    pr_diff = _fetch_pr_diff(pr_number)
    if pr_diff:
        cleaned_diff = _clean_diff(pr_diff)
        context += f"Changes in Update:\n{cleaned_diff}...\n"
    else:
        context += "Unable to fetch changes.\n"

    ai_response = _generate_response(context)
    if not ai_response:
        logger.error("Failed to generate AI response for PR update.")
        return

    logger.info("Generated AI response for PR update: %s", ai_response)

    ai_response = f"{get_aibot_pr_analysis_comment_marker()}\n{ai_response}"

    existing_comment = find_bot_comment(pr_number, get_aibot_pr_analysis_comment_marker())
    comment_id = existing_comment.get("id") if existing_comment else None

    if not comment_id:
        logger.info("No existing bot comment found. Posting a new PR analysis comment.")

    response = post_or_patch_github_comment(pr_number, ai_response, comment_id)
    if response and response.status_code in (200, 201):
        logger.info("AI Bot response posted successfully.")
    else:
        logger.error("Failed to post AI Bot response. Response: %s", getattr(response, "text", "No response"))


def aibot_handle_pr_comment(payload: Dict[str, Any]) -> None:
    """Handle PR comments where the bot is mentioned."""
    pr_number = payload.get("issue", {}).get("number")
    comment_body = payload.get("comment", {}).get("body", "")
    commenter = payload.get("comment", {}).get("user", {}).get("login")

    # TODO: Integrate with Gemini to generate a response

    logger.info(
        "AI Bot processing PR comment:\n- PR #%s\n- Comment by: %s\n- Content: %s...",
        pr_number,
        commenter,
        comment_body[:50],
    )

    ai_response = f"Hi @{commenter}, thanks for tagging me! This is a sample response to your PR comment."
    response = post_or_patch_github_comment(pr_number, ai_response)

    if response and response.status_code == 201:
        logger.info("AI Bot response posted successfully to PR comment.")
    else:
        logger.error(
            "Failed to post AI Bot response to PR comment. Response: %s", getattr(response, "text", "No response")
        )


def aibot_handle_issue_comment(payload: Dict[str, Any]) -> None:
    """Handle issue comments where the bot is mentioned."""
    issue_number = payload.get("issue", {}).get("number")
    comment_body = payload.get("comment", {}).get("body", "")
    commenter = payload.get("comment", {}).get("user", {}).get("login")

    logger.info(
        "AI Bot processing issue comment:\n- Issue #%s\n- Comment by: %s\n- Content: %s...",
        issue_number,
        commenter,
        comment_body[:50],
    )
    prompt = f"""Context:
    - This is a comment on GitHub issue #{issue_number}
    - The commenter is: @{commenter}
    - Their message was: "{comment_body}
    Generate a response for this
    """
    ai_response = _generate_response(prompt)
    response = post_or_patch_github_comment(issue_number, ai_response)

    if response and response.status_code == 201:
        logger.info("AI Bot response posted successfully to issue comment.")
    else:
        logger.error(
            "Failed to post AI Bot response to issue comment. Response: %s", getattr(response, "text", "No response")
        )


def aibot_handle_new_issue(payload: Dict[str, Any]) -> None:
    """
    Handle newly opened GitHub issues.
    Generates a contextual AI response using Gemini.
    """
    issue_number = payload.get("issue", {}).get("number")
    issue_title = payload.get("issue", {}).get("title", "No title")
    issue_body = payload.get("issue", {}).get("body", "No body")

    logger.info(
        "AI Bot processing new issue:\n- Issue #%s\n- Title: %s\n- Content: %s...",
        issue_number,
        issue_title,
        issue_body[:100],
    )

    prompt = f"""
        You are an AI assistant responding to a newly opened GitHub issue.

        Issue Title: {issue_title}
        Issue Description: {issue_body}

        Your task:
        - Briefly acknowledge the issue
        - Summarize what the issue seems to be about
        - Offer help or ask clarifying questions if needed
        - Keep it friendly and professional

        Generate a short, helpful response:
        """

    ai_response = _generate_response(prompt)

    if not ai_response:
        logger.error("Failed to generate AI response for new issue.")
        return

    logger.info("Generated AI response for new issue: %s", ai_response[:150] + "...")

    full_ai_response = f"{get_aibot_issue_analysis_comment_marker()}\n{ai_response}"
    response = post_or_patch_github_comment(issue_number, full_ai_response)

    if response and response.status_code == 201:
        logger.info("AI Bot response posted successfully to new issue #%s.", issue_number)
    else:
        logger.error(
            "Failed to post AI Bot response to new issue #%s. Response: %s",
            issue_number,
            getattr(response, "text", "No response"),
        )


def aibot_handle_issue_edited(payload: Dict[str, Any]) -> None:
    """
    Handle edited GitHub issues by analyzing the updated content and responding accordingly.

    This function:
    - Extracts the issue number, title, and body from the webhook payload.
    - Checks if the AI Bot has already commented on this issue.
    - If a comment exists, updates it with a new analysis.
    - Otherwise, posts a new comment.
    - Logs the result of the posting operation.

    Args:
        payload (Dict[str, Any]): The JSON payload from the GitHub webhook for the edited issue event.
    """
    issue_number = payload.get("issue", {}).get("number")
    issue_title = payload.get("issue", {}).get("title", "No title")
    issue_body = payload.get("issue", {}).get("body", "No body")

    logger.info(
        "AI Bot processing edited issue:\n- Issue #%s\n- Title: %s\n- Content: %s...",
        issue_number,
        issue_title,
        issue_body[:100],
    )

    prompt = f"""
        You are an AI assistant responding to an updated GitHub issue.

        Issue Title: {issue_title}
        Updated Description: {issue_body}

        Your task:
        - Acknowledge the update
        - Briefly summarize what changed
        - Ask clarifying questions if needed
        - Keep it friendly and professional

        Generate a short, helpful response:
        """

    ai_response = _generate_response(prompt)

    if not ai_response:
        logger.error("Failed to generate AI response for edited issue.")
        return

    logger.info("Generated AI response for edited issue: %s", ai_response[:150] + "...")

    full_ai_response = f"{get_aibot_issue_analysis_comment_marker()}\n{ai_response}"

    existing_comment = find_bot_comment(issue_number, get_aibot_issue_analysis_comment_marker())

    if existing_comment:
        comment_id = existing_comment["id"]
        logger.info("Found existing bot comment. Updating it with new analysis.")
        response = post_or_patch_github_comment(issue_number, full_ai_response, comment_id)
    else:
        logger.info("No existing bot comment found. Posting a new issue analysis comment.")
        response = post_or_patch_github_comment(issue_number, full_ai_response)

    if response and response.status_code == 201:
        logger.info("AI Bot response posted successfully to edited issue #%s.", issue_number)
    else:
        logger.error(
            "Failed to post AI Bot response to edited issue #%s. Response: %s",
            issue_number,
            getattr(response, "text", "No response"),
        )


def find_bot_comment(issue_number: str, marker: str) -> Optional[dict]:
    """
    Find an existing comment made by the bot in a GitHub issue or pull request.

    Args:
        issue_number (str): The number of the GitHub issue or PR.
        marker (str): A unique string used to identify the specific bot comment.

    Returns:
        Optional[dict]: The matching comment object if found, otherwise None.
    """
    try:
        url = f"{get_github_api_url()}/issues/{issue_number}/comments"
        headers = {
            "Authorization": f"Bearer {get_github_aibot_token()}",
            "Accept": "application/vnd.github+json",
        }
        response = requests.get(url, headers=headers, timeout=10)

        if response.status_code == 200:
            comments = response.json()
            bot_username = get_github_aibot_username().lower()

            for comment in comments:
                author = comment.get("user", {}).get("login", "").lower()
                body = comment.get("body", "").lower()
                if author == bot_username and marker.lower() in body:
                    return comment
        else:
            logger.warning("GitHub API returned status %s while fetching comments.", response.status_code)
        return None
    except Exception as e:
        logger.error("Failed to fetch comments: %s", str(e))
        return None


def validate_payload_schema(payload: Dict[str, Any], schema: Dict[str, Any]) -> None:
    """
    Validate the payload against the provided schema.

    Args:
        payload (Dict[str, Any]): The payload to validate.
        schema (Dict[str, Any]): The JSON schema to validate against.

    Returns:
        None. Raises ValidationError if the payload does not conform to the schema, which is handled by the caller.
    """
    validate(instance=payload, schema=schema)


def post_or_patch_github_comment(
    issue_number: str, comment: str, comment_id: Optional[str] = None
) -> Optional[requests.Response]:
    """
    Post a new comment or patch an existing one on a GitHub issue/pull request.

    Args:
        issue_number (str): The issue or pull request number.
        comment (str): The comment body to post or update.
        comment_id (Optional[str]): If present, edits the existing comment with this ID.

    Returns:
        Optional[requests.Response]: The response object if the request succeeds, otherwise None.

    Retries:
        Retries up to MAX_RETRIES times on network errors or transient server errors (HTTP 502, 503, 504),
        with exponential backoff.
    """
    if not issue_number or not comment.strip():
        logger.error("Invalid input: empty issue number or comment.")
        return None

    if comment_id:
        url = f"{get_github_api_url()}/issues/comments/{comment_id}"
    else:
        url = f"{get_github_api_url()}/issues/{issue_number}/comments"

    headers = {
        "Authorization": f"Bearer {get_github_aibot_token()}",
        "Accept": "application/vnd.github+json",
        "Content-Type": "application/json",
        "User-Agent": f"{get_github_aibot_username()}/1.0",
    }

    for attempt in range(1, MAX_RETRIES + 1):
        try:
            method = requests.patch if comment_id else requests.post
            response = method(url, json={"body": comment}, headers=headers, timeout=10)
            logger.info("Attempt %d to %s comment on #%s", attempt, "update" if comment_id else "post", issue_number)

            if response.status_code == 201 or (response.status_code == 200 and comment_id):
                logger.info(
                    "%s comment successfully posted/updated on #%s", "Updated" if comment_id else "Posted", issue_number
                )
                return response
            if response.status_code in {502, 503, 504}:
                logger.warning(
                    "Transient error (%s). Retrying attempt %d/%d...", response.status_code, attempt, MAX_RETRIES
                )
            elif response.status_code == 403 and response.headers.get("X-RateLimit-Remaining") == "0":
                reset_time = int(response.headers.get("X-RateLimit-Reset", "0"))
                sleep_seconds = max(reset_time - int(time.time()), 0)
                logger.warning("Rate limit exceeded. Sleeping for %d seconds...", sleep_seconds)
                time.sleep(sleep_seconds)
                continue
            else:
                logger.error(
                    "Failed to %s comment. Status: %s, Response: %s",
                    "update" if comment_id else "post",
                    response.status_code,
                    response.text,
                )
                return response

        except requests.RequestException as e:
            logger.exception("Network error on attempt %d/%d: %s", attempt, MAX_RETRIES, str(e))

        if attempt < MAX_RETRIES:
            wait_time = RETRY_BACKOFF * (2 ** (attempt - 1)) + random.uniform(0, 1)
            logger.info("Retrying in %.1fs...", wait_time)
            time.sleep(wait_time)

    logger.error(
        "All retry attempts failed for %s comment on #%s", "updating" if comment_id else "posting", issue_number
    )
    return None


def _clean_diff(diff_text: str) -> str:
    lines = diff_text.split("\n")
    cleaned_lines = []
    for line in lines:
        if line.startswith(("index", "---", "+++", "@@")):
            continue
        cleaned_lines.append(line)
    return "\n".join(cleaned_lines)


def _fetch_pr_diff(pr_number: int) -> Optional[str]:
    """
    Fetches PR diff using GitHub API

    Args:
        pr_number: Pull request number

    Returns:
        Diff text or None if failed
    """
    api_url = f"{get_github_api_url()}/pulls/{pr_number}"
    headers = {
        "Authorization": f"Bearer {get_github_aibot_token()}",
        "Accept": "application/vnd.github.v3.diff",
    }

    try:
        response = requests.get(api_url, headers=headers, timeout=10)
        response.raise_for_status()
        return response.text
    except requests.RequestException as e:
        logger.error("Failed to fetch PR diff: %s", str(e))
        return None


def verify_github_signature(secret: str, payload_body: bytes, signature_header: str) -> bool:
    """
    Verifies the GitHub webhook signature using HMAC SHA256.

    Args:
        secret (str): Webhook secret key.
        payload_body (bytes): Raw request body.
        signature_header (str): Value from 'X-Hub-Signature-256' header.

    Returns:
        bool: True if the signature is valid, False otherwise.
    """
    if not signature_header or not signature_header.startswith("sha256="):
        return False

    if not secret:
        logger.error("Webhook secret not configured; cannot verify signature.")
        return False

    try:
        received_signature = signature_header.split("=", 1)[1]
    except IndexError:
        return False

    mac = hmac.new(secret.encode(), payload_body, hashlib.sha256)
    expected_signature = mac.hexdigest()

    return hmac.compare_digest(expected_signature, received_signature)

Modified: website/views/core.py
@@ -76,6 +76,7 @@
     safe_redirect_allowed,
     save_analysis_report,
 )
+from website.views.aibot import aibot_webhook_is_healthy
 
 # from website.bot import conversation_chain, is_api_key_valid, load_vector_store
 
@@ -138,6 +139,7 @@ def status_page(request):
     CHECK_BITCOIN = False
     CHECK_SENDGRID = True
     CHECK_GITHUB = True
+    CHECK_GITHUB_AIBOT_WEBHOOK = True
     CHECK_OPENAI = True
     CHECK_MEMORY = True
     CHECK_DATABASE = True
@@ -145,7 +147,8 @@ def status_page(request):
     CHECK_SLACK_BOT = True
     CACHE_TIMEOUT = 60
 
-    status_data = cache.get("service_status")
+    # status_data = cache.get("service_status")
+    status_data = None
 
     if not status_data:
         status_data = {
@@ -165,6 +168,10 @@ def status_page(request):
                 if not CHECK_REDIS
                 else {}
             ),
+            "github_aibot_webhook": {
+                "health": None if not CHECK_GITHUB_AIBOT_WEBHOOK else "3",
+                "status": "Not checked",
+            },
             "slack_bot": {},
             "management_commands": [],
             "available_commands": [],
@@ -327,6 +334,21 @@ def status_page(request):
                     print(f"GitHub API Error: {e}")
                     status_data["github_rate_limit"] = None
 
+        # GitHub AI Bot Webhook check
+        if CHECK_GITHUB_AIBOT_WEBHOOK:
+            try:
+                webhook_resp = aibot_webhook_is_healthy(request)
+                webhook_data = json.loads(webhook_resp.content)
+                status_data["github_aibot_webhook"] = webhook_data
+                status_data["github_aibot_webhook"]["last_checked"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
+            except Exception as e:
+                status_data["github_aibot_webhook"] = {
+                    "health": "2",
+                    "status": "Error during health check",
+                    "error": str(e),
+                    "last_checked": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
+                }
+
         # OpenAI API check
         if CHECK_OPENAI:
             openai_api_key = os.getenv("OPENAI_API_KEY", "sk-proj-1234567890")


Static analysis results:
Not found

Relevant code snippets from main repository:
File: website/views/aibot.py
Lines: 490–526
```python
def aibot_handle_pr_update(payload: Dict[str, Any]) -> None:
    """This function handles the logic when a PR is updated with new commits."""
    logger.info("Handling PR update.")
    pr = payload.get("pull_request", {})
    pr_number = pr.get("number")
    pr_title = pr.get("title", "No title")
    head_ref = pr["head"]["ref"]

    context = f"PR Title: {pr_title}\n"

    pr_diff = _fetch_pr_diff(pr_number)
    if pr_diff:
        cleaned_diff = _process_diff(pr_diff, head_ref)
        context += f"Changes in Update:\n{cleaned_diff}...\n"
    else:
        context += "Unable to fetch changes.\n"

    ai_response = _generate_response(context)
    if not ai_response:
        logger.error("Failed to generate AI response for PR update.")
        return

    logger.info("Generated AI response for PR update: %s", ai_response)

    ai_response = f"{get_aibot_pr_analysis_comment_marker()}\n{ai_response}"

    existing_comment = find_bot_comment(pr_number, get_aibot_pr_analysis_comment_marker())
    comment_id = existing_comment.get("id") if existing_comment else None

    if not comment_id:
        logger.info("No existing bot comment found. Posting a new PR analysis comment.")

    response = post_or_patch_github_comment(pr_number, ai_response, comment_id)
    if response and response.status_code in (200, 201):
        logger.info("AI Bot response posted successfully.")
    else:
        logger.error("Failed to post AI Bot response. Response: %s", getattr(response, "text", "No response"))
```

File: website/test_aibot.py
Lines: 9–185
```python
@override_settings(GITHUB_AIBOT_WEBHOOK_SECRET="test_secret")
@override_settings(LOGGING={"version": 1, "disable_existing_loggers": True})
class MainGitHubWebhookDispatcherTests(TestCase):
    def setUp(self):
        self.url = reverse("main_github_aibot_webhook_dispatcher")
        self.valid_headers = {
            "X-GitHub-Event": "ping",
            "X-Hub-Signature-256": "sha256=valid_signature",
            "Content-Type": "application/json",
        }
        self.valid_body = json.dumps({"zen": "Test message"})

    def test_invalid_http_method(self):
        """Test GET request rejection (non POST request) )"""
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 400)
        self.assertIn("Only POST requests", response.content.decode())

    def test_missing_signature(self):
        """Test signature verification"""
        invalid_headers = self.valid_headers.copy()
        del invalid_headers["X-Hub-Signature-256"]
        invalid_headers["X-GitHub-Event"] = "pull_request"
        response = self.client.post(
            self.url, data=self.valid_body, headers=invalid_headers, content_type="application/json"
        )
        self.assertEqual(response.status_code, 403)
        self.assertIn("Missing webhook signature header", response.json()["error"])

    def test_invalid_signature(self):
        """Test invalid signature handling"""
        invalid_headers = self.valid_headers.copy()
        invalid_headers["X-Hub-Signature-256"] = "sha256=invalid_signature"
        invalid_headers["X-GitHub-Event"] = "pull_request"
        response = self.client.post(
            self.url, data=self.valid_body, headers=invalid_headers, content_type="application/json"
        )
        self.assertEqual(response.status_code, 403)
        self.assertIn("Invalid webhook signature", response.json()["error"])

    def test_empty_request_body(self):
        """Test empty request body handling"""
        response = self.client.post(self.url, data="", headers=self.valid_headers, content_type="application/json")
        self.assertEqual(response.status_code, 400)
        self.assertIn("Empty request body", response.json()["error"])

    def test_invalid_json(self):
        """Test malformed JSON handling"""
        response = self.client.post(
            self.url, data="INVALID_JSON", headers=self.valid_headers, content_type="application/json"
        )
        self.assertEqual(response.status_code, 400)
        self.assertIn("Invalid JSON payload", response.json()["error"])

    @patch("website.views.aibot.verify_github_signature", return_value=True)
    def test_missing_event_header(self, mock_verify_signature):
        """Test missing event header handling"""
        headers = self.valid_headers.copy()
        del headers["X-GitHub-Event"]
        response = self.client.post(self.url, data=self.valid_body, headers=headers, content_type="application/json")
        self.assertEqual(response.status_code, 400)
        self.assertIn("Missing X-GitHub-Event header", response.json()["error"])

    @patch("website.views.aibot.verify_github_signature", return_value=True)

```

File: website/views/user.py
Lines: 855–883
```python
@csrf_exempt
def github_webhook(request):
    if request.method == "POST":
        # Validate GitHub signature
        # this doesn't seem to work?
        # signature = request.headers.get("X-Hub-Signature-256")
        # if not validate_signature(request.body, signature):
        #    return JsonResponse({"status": "error", "message": "Unauthorized request"}, status=403)

        payload = json.loads(request.body)
        event_type = request.headers.get("X-GitHub-Event", "")

        event_handlers = {
            "pull_request": handle_pull_request_event,
            "push": handle_push_event,
            "pull_request_review": handle_review_event,
            "issues": handle_issue_event,
            "status": handle_status_event,
            "fork": handle_fork_event,
            "create": handle_create_event,
        }

        handler = event_handlers.get(event_type)
        if handler:
            return handler(payload)
        else:
            return JsonResponse({"status": "error", "message": "Unhandled event type"}, status=400)
    else:
        return JsonResponse({"status": "error", "message": "Invalid method"}, status=400)
```

File: blt/urls.py
Lines: 362–1101
```python
urlpatterns = [
    path("banned_apps/", BannedAppsView.as_view(), name="banned_apps"),
    path("api/banned_apps/search/", search_banned_apps, name="search_banned_apps"),
    path("500/", TemplateView.as_view(template_name="500.html"), name="500"),
    path("", home, name="home"),
    path("invite-friend/", invite_friend, name="invite_friend"),
    path("referral/", referral_signup, name="referral_signup"),
    path("captcha/refresh/", captcha_refresh, name="captcha-refresh-debug"),
    path("captcha/", include("captcha.urls")),
    re_path(r"^auth/registration/", include("dj_rest_auth.registration.urls")),
    path(
        "rest-auth/password/reset/confirm/<str:uidb64>/<str:token>",
        PasswordResetConfirmView.as_view(),
        name="password_reset_confirm",
    ),
    re_path(r"^auth/", include("dj_rest_auth.urls")),
    re_path("auth/facebook", FacebookLogin.as_view(), name="facebook_login"),
    path("accounts/", include("allauth.urls")),
    path("accounts/delete/", UserDeleteView.as_view(), name="user_deletion"),
    path("auth/github/", GithubLogin.as_view(), name="github_login"),
    path("accounts/github/login/callback/", github_callback, name="github_callback"),
    re_path(r"^auth/github/connect/$", GithubConnect.as_view(), name="github_connect"),
    path("auth/github/url/", github_views.oauth2_login),
    path("auth/google/", GoogleLogin.as_view(), name="google_login"),
    path("accounts/google/login/callback/", google_callback, name="google_callback"),
    path("accounts/facebook/login/callback/", facebook_callback, name="facebook_callback"),
    re_path(r"^auth/facebook/connect/$", FacebookConnect.as_view(), name="facebook_connect"),
    re_path(r"^auth/google/connect/$", GoogleConnect.as_view(), name="google_connect"),
    path("auth/github/url/", github_views.oauth2_login),
    path(
        "oauth/slack/callback/",
        SlackCallbackView.as_view(),
        name="slack_oauth_callback",
    ),
    path("slack/commands/", slack_commands, name="slack_commands"),
    path("auth/google/url/", google_views.oauth2_login),
    path("auth/facebook/url/", facebook_views.oauth2_callback),
    path("socialaccounts/", SocialAccountListView.as_view(), name="social_account_list"),
    path(
        "add_domain_to_organization/",
        add_domain_to_organization,
        name="add_domain_to_organization",
    ),
    path(
        "socialaccounts/<int:pk>/disconnect/",
        CustomSocialAccountDisconnectView.as_view(),
        name="social_account_disconnect",
    ),
    re_path(
        r"^swagger(?P<format>\.json|\.yaml)$",
        schema_view.without_ui(cache_timeout=0),
        name="schema-json",
    ),
    re_path(
        r"^swagger/$",
        schema_view.with_ui("swagger", cache_timeout=0),
        name="schema-swagger-ui",
    ),
    re_path(r"^redoc/$", schema_view.with_ui("redoc", cache_timeout=0), name="schema-redoc"),
    re_path(r"^issues/$", newhome, name="issues"),
    re_path(
        r"^dashboard/organization/$",
        organization_dashboard,
        name="organization_dashboard_home",
    ),
    re_path(
        r"^dashboard/admin/organization$",
        admin_organization_dashboard,
        name="admin_organization_dashboard",
    ),
    re_path(
        r"^dashboard/admin/organization/addorupdate$",
        add_or_update_organization,
        name="add_or_update_organization",
    ),
    re_path(
        r"^dashboard/organization/domain/addorupdate$",
        add_or_update_domain,
        name="add_or_update_domain",
    ),
    path(
        "dashboard/organization/domain/<int:pk>/",
        organization_dashboard_domain_detail,
        name="organization_dashboard_domain_detail",
    ),
    path(
        "dashboard/organization/hunt/<int:pk>/",
        organization_dashboard_hunt_detail,
        name="organization_dashboard_hunt_detail",
    ),
    path("dashboard/user/hunt/<int:pk>/", view_hunt, name="view_hunt"),
    path(
        "dashboard/user/hunt/<int:pk>/submittion/",
        submit_bug,
        name="submit_bug",
    ),
    path(
        "dashboard/user/hunt/<int:pk>/results/",
        hunt_results,
        name="hunt_results",
    ),
    path(
        "dashboard/organization/hunt/<int:pk>/edit",
        organization_dashboard_hunt_edit,
        name="organization_dashboard_hunt_edit",
    ),
    path("aibot", main_github_aibot_webhook_dispatcher, name="main_github_aibot_webhook_dispatcher"),
    path("aibot_webhook_is_healthy", aibot_webhook_is_healthy, name="aibot_webhook_is_healthy"),
    path(
        "dashboard/admin/organization/<int:pk>/",
        admin_organization_dashboard_detail,
        name="admin_organization_dashboard_detail",
    ),
    re_path(
        r"^dashboard/organization/hunt/create$",
        CreateHunt.as_view(),
        name="create_hunt",
    ),
    path("hunt/<int:pk>", ShowBughuntView.as_view(), name="show_bughunt"),
    re_path(
        r"^dashboard/organization/hunt/drafts$",
        DraftHunts.as_view(),
        name="draft_hunts",
    ),
    re_path(
        r"^dashboard/organization/hunt/upcoming$",
        UpcomingHunts.as_view(),
        name="upcoming_hunts",
    ),
    re_path(
        r"^dashboard/organization/hunt/previous$",
        PreviousHunts.as_view(),
        name="previous_hunts",
    ),
    path(
        "dashboard/organization/hunt/previous/<int:pk>/",
        organization_hunt_results,
        name="organization_hunt_results",
    ),
    re_path(
        r"^dashboard/organization/hunt/ongoing$",
        OngoingHunts.as_view(),
        name="ongoing_hunts",
    ),
    re_path(r"^dashboard/organization/domains$", DomainList.as_view(), name="domain_list"),
    re_path(
        r"^dashboard/organization/settings$",
        OrganizationSettings.as_view(),
        name="organization-settings",
    ),
    re_path(r"^join$", Joinorganization.as_view(), name="join"),
    re_path(
        r"^dashboard/organization/settings/role/update$",
        update_role,
        name="update-role",
    ),
    re_path(
        r"^dashboard/user/$",
        user_dashboard,
        name="user",
    ),
    path(settings.ADMIN_URL + "/", admin.site.urls),
    re_path(r"^like_issue/(?P<issue_pk>\d+)/$", like_issue, name="like_issue"),
    re_path(
        r"^dislike_issue/(?P<issue_pk>\d+)/$",
        dislike_issue,
        name="dislike_issue",
    ),
    re_path(r"^flag_issue/(?P<issue_pk>\d+)/$", flag_issue, name="flag_issue"),
    re_path(r"^resolve/(?P<id>\w+)/$", resolve, name="resolve"),
    re_path(
        r"^create_github_issue/(?P<id>\w+)/$",
        create_github_issue,
        name="create_github_issue",
    ),
    re_path(r"^vote_count/(?P<issue_pk>\d+)/$", vote_count, name="vote_count"),
    path("domain/<int:pk>/subscribe/", subscribe_to_domains, name="subscribe_to_domains"),
    re_path(r"^save_issue/(?P<issue_pk>\d+)/$", save_issue, name="save_issue"),
    path("profile/edit/", profile_edit, name="profile_edit"),
    re_path(
        r"^unsave_issue/(?P<issue_pk>\d+)/$",
        unsave_issue,
        name="unsave_issue",
    ),
    re_path(r"^issue/edit/$", IssueEdit, name="edit_issue"),
    re_path(r"^issue/update/$", UpdateIssue, name="update_issue"),
    # comment on content
    path(
        "content/<str:content_pk>/comment/",
        comment_on_content,
        name="comment_on_content",
    ),
    # update comment
    path(
        "content/<str:content_pk>/comment/update/<str:comment_pk>/",
        update_content_comment,
        name="update_content_comment",
    ),
    # delete comment
    path("content/comment/delete/", delete_content_comment, name="delete_content_comment"),
    re_path(r"^issue/(?P<slug>\w+)/$", IssueView.as_view(), name="issue_view"),
    re_path(r"^follow/(?P<user>[^/]+)/", follow_user, name="follow_user"),
    re_path(r"^all_activity/$", AllIssuesView.as_view(), name="all_activity"),
    re_path(r"^label_activity/$", SpecificIssuesView.as_view(), name="all_activitys"),
    re_path(r"^leaderboard/$", GlobalLeaderboardView.as_view(), name="leaderboard_global"),
    re_path(
        r"^leaderboard/monthly/$",
        SpecificMonthLeaderboardView.as_view(),
        name="leaderboard_specific_month",
    ),
    re_path(
        r"^leaderboard/each-month/$",
        EachmonthLeaderboardView.as_view(),
        name="leaderboard_eachmonth",
    ),
    re_path(
        r"^api/v1/issue/like/(?P<id>\w+)/$",
        LikeIssueApiView.as_view(),
        name="api_like_issue",
    ),
    re_path(
        r"^api/v1/issue/flag/(?P<id>\w+)/$",
        FlagIssueApiView.as_view(),
        name="api_flag_issue",
    ),
    re_path(r"^api/v1/leaderboard/$", LeaderboardApiViewSet.as_view(), name="leaderboard"),
    re_path(
        r"^api/v1/invite_friend/",
        InviteFriendApiViewset.as_view(),
        name="api_invite_friend",
    ),
    path("scoreboard/", ScoreboardView.as_view(), name="scoreboard"),
    re_path(r"^issue/$", IssueCreate.as_view(), name="issue"),
    # link to index.html
    re_path(
        r"^upload/(?P<time>[^/]+)/(?P<hash>[^/]+)/",
        UploadCreate.as_view(),
        name="upload",
    ),
    re_path(r"^profile/(?P<slug>[^/]+)/$", UserProfileDetailView.as_view(), name="profile"),
    re_path(r"^domain/(?P<slug>.+)/$", DomainDetailView.as_view(), name="domain"),
    re_path(
        r"^.well-known/acme-challenge/(?P<token>[^/]+)/$",
        find_key,
        name="find_key",
    ),
    re_path(r"^accounts/profile/", profile, name="account_profile"),
    path("delete_issue/<str:id>/", ensure_csrf_cookie(delete_issue), name="delete_issue"),
    re_path(
        r"^remove_user_from_issue/(?P<id>\w+)/$",
        remove_user_from_issue,
        name="remove_user_from_issue",
    ),
    re_path(r"^accounts/", include("allauth.urls")),
    re_path(
        r"^sitemap/$",
        sitemap,
        name="sitemap",
    ),
    re_path(
        r"^badges/$",
        badge_list,
        name="badges",
    ),
    re_path(
        r"^badges/(?P<badge_id>\d+)/users/$",
        badge_user_list,
        name="badge_user_list",
    ),
    re_path(r"^start/$", TemplateView.as_view(template_name="hunt.html"), name="start_hunt"),
    re_path(r"^hunt/$", login_required(HuntCreate.as_view()), name="hunt"),
    re_path(r"^bounties/$", Listbounties.as_view(), name="hunts"),
    path("bounties/payouts/", BountyPayoutsView.as_view(), name="bounty_payouts"),
    path("api/load-more-issues/", load_more_issues, name="load_more_issues"),
    re_path(r"^invite/$", InviteCreate.as_view(template_name="invite.html"), name="invite"),
    re_path(r"^terms/$", TemplateView.as_view(template_name="terms.html"), name="terms"),
    re_path(r"^about/$", TemplateView.as_view(template_name="about.html"), name="about"),
    re_path(r"^teams/$", TemplateView.as_view(template_name="teams.html"), name="teams"),
    path("notifications/fetch/", fetch_notifications, name="fetch_notifications"),
    path("notifications/mark_all_read", mark_as_read, name="mark_all_read"),
    path("notifications/delete_notification/<int:notification_id>", delete_notification, name="delete_notification"),
    re_path(
        r"^googleplayapp/$",
        TemplateView.as_view(template_name="coming_soon.html"),
        name="googleplayapp",
    ),
    re_path(r"^projects/$", ProjectView.as_view(), name="project_list"),
    re_path(r"^apps/$", TemplateView.as_view(template_name="apps.html"), name="apps"),
    re_path(
        r"^deletions/$",
        deletions,
        name="deletions",
    ),
    re_path(r"^bacon/$", bacon_view, name="bacon"),
    re_path(r"^education/$", education_home, name="education"),
    path("education/instructor_dashboard/", instructor_dashboard, name="instructor_dashboard"),
    path("education/create-standalone-lecture/", create_standalone_lecture, name="create_standalone_lecture"),
    path("education/edit-standalone-lecture/<int:lecture_id>", edit_standalone_lecture, name="edit_standalone_lecture"),
    path("education/instructor_dashboard/edit-course/<int:course_id>/", edit_course, name="edit_course"),
    path(
        "education/instructor_dashboard/create-or-update-course/",
        create_or_update_course,
        name="create_or_update_course",
    ),
    path("education/view-course/<int:course_id>/", view_course, name="view_course"),
    path("education/view-lecture/<int:lecture_id>/", view_lecture, name="view_lecture"),
    path("education/enroll/<int:course_id>/", enroll, name="enroll"),
    path("education/study_course/<int:course_id>/", study_course, name="study_course"),
    path("education/mark-lecture-complete/", mark_lecture_complete, name="mark_lecture_complete"),
    path("education/get-course-content/<int:course_id>/", get_course_content, name="get_course_content"),
    path(
        "education/course-content-management/<int:course_id>/",
        course_content_management,
        name="course_content_management",
    ),
    path("education/instructor_dashboard/courses/<int:course_id>/sections/add/", add_section, name="add_section"),
    path("education/instructor_dashboard/sections/<int:section_id>/edit/", edit_section, name="edit_section"),
    path("education/instructor_dashboard/sections/<int:section_id>/delete/", delete_section, name="delete_section"),
    # Lecture management
    path("education/instructor_dashboard/sections/<int:section_id>/lectures/add/", add_lecture, name="add_lecture"),
    path("education/instructor_dashboard/lectures/<int:lecture_id>/edit/", edit_lecture, name="edit_lecture"),
    path("education/instructor_dashboard/lectures/<int:lecture_id>/delete/", delete_lecture, name="delete_lecture"),
    # API endpoints
    path("education/instructor_dashboard/api/lectures/<int:lecture_id>/", get_lecture_data, name="get_lecture_data"),
    path("education/instructor_dashboard/api/sections/<int:section_id>/", get_section_data, name="get_section_data"),
    path(
        "education/instructor_dashboard/courses/<int:course_id>/sections/reorder/",
        update_sections_order,
        name="update_sections_order",
    ),
    path(
        "education/instructor_dashboard/sections/<int:section_id>/lectures/reorder/",
        update_lectures_order,
        name="update_lectures_order",
    ),
    path("gsoc/", GsocView.as_view(), name="gsoc"),
    path("gsoc/refresh/", refresh_gsoc_project, name="refresh_gsoc_project"),
    re_path(
        r"^privacypolicy/$",
        TemplateView.as_view(template_name="privacy.html"),
        name="privacy",
    ),
    re_path(r"^stats/$", StatsDetailView.as_view(), name="stats"),
    re_path(r"^favicon\.ico$", favicon_view),
    re_path(
        r"^sendgrid_webhook/$",
        csrf_exempt(InboundParseWebhookView.as_view()),
        name="inbound_event_webhook_callback",
    ),
    re_path(r"^status_page/$", status_page, name="status_page"),
    re_path(r"^status/run-command/$", run_management_command, name="run_management_command"),
    re_path(r"^status/commands/$", management_commands, name="management_commands"),
    path(r"website_stats/", website_stats, name="website_stats"),
    re_path(r"^issue/comment/add/$", comments.views.add_comment, name="add_comment"),
    re_path(r"^issue/comment/delete/$", comments.views.delete_comment, name="delete_comment"),
    re_path(r"^comment/autocomplete/$", comments.views.autocomplete, name="autocomplete"),
    re_path(
        r"^issue/(?P<pk>\d+)/comment/edit/$",
        comments.views.edit_comment,
        name="edit_comment",
    ),
    re_path(
        r"^issue/(?P<pk>\d+)/comment/reply/$",
        comments.views.reply_comment,
        name="reply_comment",
    ),
    re_path(r"^social/$", queue_social_view, name="social"),
    re_path(r"^search/$", search, name="search"),
    re_path(r"^report/$", IssueCreate.as_view(), name="report"),
    re_path(r"^i18n/", include("django.conf.urls.i18n")),
    re_path(r"^api/v1/", include(router.urls)),
    re_path(r"^api/v1/stats/$", StatsApiViewset.as_view(), name="get_score"),
    re_path(r"^api/v1/urlcheck/$", UrlCheckApiViewset.as_view(), name="url_check"),
    re_path(r"^api/v1/hunt/$", BugHuntApiViewset.as_view(), name="hunt_details"),
    re_path(r"^api/v2/hunts/$", BugHuntApiViewsetV2.as_view(), name="hunts_detail_v2"),
    re_path(r"^api/v1/userscore/$", get_score, name="get_score"),
    re_path(r"^authenticate/", CustomObtainAuthToken.as_view()),
    re_path(r"^api/v1/createwallet/$", create_wallet, name="create_wallet"),
    re_path(r"^api/v1/count/$", issue_count, name="api_count"),
    re_path(r"^api/v1/contributors/$", contributors, name="api_contributor"),
    path("projects/<slug:slug>/badge/", ProjectBadgeView.as_view(), name="project-badge"),
    path("repos/<slug:slug>/badge/", RepoBadgeView.as_view(), name="repo-badge"),
    path("repository/<slug:slug>/", RepoDetailView.as_view(), name="repo_detail"),
    path("repository/<int:repo_id>/refresh/", refresh_repo_data, name="refresh_repo_data"),
    re_path(r"^report-ip/$", ReportIpView.as_view(), name="report_ip"),
    re_path(r"^reported-ips/$", ReportedIpListView.as_view(), name="reported_ips_list"),
    re_path(r"^feed/$", feed, name="feed"),
    re_path(
        r"^api/v1/createissues/$",
        csrf_exempt(IssueCreate.as_view()),
        name="issuecreate",
    ),
    re_path(
        r"^api/v1/search/$",
        csrf_exempt(search_issues),
        name="search_issues",
    ),
    re_path(
        r"^api/v1/delete_issue/(?P<id>\w+)/$",
        csrf_exempt(delete_issue),
        name="delete_api_issue",
    ),
    re_path(
        r"^api/v1/remove_user_from_issue/(?P<id>\w+)/$",
        csrf_exempt(remove_user_from_issue),
        name="remove_api_user_from_issue",
    ),
    re_path(
        r"^api/v1/issue/update/$",
        csrf_exempt(UpdateIssue),
        name="update_api_issue",
    ),
    re_path(r"^api/v1/scoreboard/$", get_scoreboard, name="api_scoreboard"),
    re_path(
        r"^api/v1/terms/$",
        csrf_exempt(TemplateView.as_view(template_name="mobile_terms.html")),
        name="api_terms",
    ),
    re_path(
        r"^api/v1/about/$",
        csrf_exempt(TemplateView.as_view(template_name="mobile_about.html")),
        name="api_about",
    ),
    re_path(
        r"^api/v1/privacypolicy/$",
        csrf_exempt(TemplateView.as_view(template_name="mobile_privacy.html")),
        name="api_privacypolicy",
    ),
    re_path(
        r"^contribute/$",
        ContributeView.as_view(),
        name="contribution_guidelines",
    ),
    path("select_contribution/", select_contribution, name="select_contribution"),
    path(
        "distribute_bacon/<int:contribution_id>/",
        distribute_bacon,
        name="distribute_bacon",
    ),
    path("activity/like/<int:id>/", like_activity, name="like_activity"),
    path("activity/dislike/<int:id>/", dislike_activity, name="dislike_activity"),
    path("activity/approve/<int:id>/", approve_activity, name="approve_activity"),
    re_path(r"^tz_detect/", include("tz_detect.urls")),
    re_path(r"^ratings/", include("star_ratings.urls", namespace="ratings")),
    re_path(r"^robots\.txt$", robots_txt),
    re_path(r"^contributors/$", contributors_view, name="contributors"),
    # users
    path("users/", users_view, name="users"),
    # company specific urls :
    path(
        "organization/",
        RegisterOrganizationView.as_view(),
        name="register_organization",
    ),
    path("organization/view", Organization_view, name="organization_view"),
    path("organization/dashboard/", dashboard_view, name="organization_dashboard"),
    path(
        "organization/<int:id>/dashboard/analytics/",
        OrganizationDashboardAnalyticsView.as_view(),
        name="organization_analytics",
    ),
    path(
        "organization/<int:id>/dashboard/integrations/",
        OrganizationDashboardIntegrations.as_view(),
        name="organization_manage_integrations",
    ),
    path(
        "organization/<int:id>/dashboard/bugs/",
        OrganizationDashboardManageBugsView.as_view(),
        name="organization_manage_bugs",
    ),
    path(
        "organization/<int:id>/dashboard/team-overview/",
        OrganizationDashboardTeamOverviewView.as_view(),
        name="organization_team_overview",
    ),
    path(
        "organization/<int:id>/dashboard/domains/",
        OrganizationDashboardManageDomainsView.as_view(),
        name="organization_manage_domains",
    ),
    path(
        "organization/<int:id>/dashboard/roles/",
        OrganizationDashboardManageRolesView.as_view(),
        name="organization_manage_roles",
    ),
    path(
        "organization/<int:id>/dashboard/bughunts/",
        OrganizationDashboardManageBughuntView.as_view(),
        name="organization_manage_bughunts",
    ),
    path(
        "organization/dashboard/end_bughunt/<int:pk>",
        EndBughuntView.as_view(),
        name="end_bughunt",
    ),
    path(
        "organization/<int:id>/dashboard/add_bughunt/",
        AddHuntView.as_view(),
        name="add_bughunt",
    ),
    path(
        "organization/<int:id>/dashboard/add_domain/",
        AddDomainView.as_view(),
        name="add_domain",
    ),
    path(
        "organization/<int:id>/dashboard/add_slack_integration/",
        AddSlackIntegrationView.as_view(),
        name="add_slack_integration",
    ),
    path(
        "organization/<int:id>/dashboard/edit_domain/<int:domain_id>/",
        AddDomainView.as_view(),
        name="edit_domain",
    ),
    path(
        "organization/domain/<int:pk>/",
        login_required(DomainView.as_view()),
        name="view_domain",
    ),
    path(
        "organization/delete_prize/<int:prize_id>/<int:organization_id>",
        delete_prize,
        name="delete_prize",
    ),
    path(
        "organization/edit_prize/<int:prize_id>/<int:organization_id>",
        edit_prize,
        name="edit_prize",
    ),
    path(
        "organization/accept_bug/<int:issue_id>/<str:reward_id>/",
        accept_bug,
        name="accept_bug",
    ),
    path(
        "organization/accept_bug/<int:issue_id>/<str:no_reward>/",
        accept_bug,
        name="accept_bug_no_reward",
    ),
    path(
        "organization/delete_manager/<int:manager_id>/<int:domain_id>/",
        delete_manager,
        name="delete_manager",
    ),
    path("features/", features_view, name="features"),
    path("sponsor/", sponsor_view, name="sponsor"),
    path("donate/", donate_view, name="donate"),
    path("organizations/", OrganizationListView.as_view(), name="organizations"),
    path("map/", MapView.as_view(), name="map"),
    path("domains/", DomainListView.as_view(), name="domains"),
    path("trademarks/", trademark_search, name="trademark_search"),
    path(
        "generate_bid_image/<int:bid_amount>/",
        generate_bid_image,
        name="generate_bid_image",
    ),
    path("bidding/", SaveBiddingData, name="BiddingData"),
    path("select_bid/", select_bid, name="select_bid"),
    path("get_unique_issues/", get_unique_issues, name="get_unique_issues"),
    path("change_bid_status/", change_bid_status, name="change_bid_status"),
    path("fetch-current-bid/", fetch_current_bid, name="fetch_current_bid"),
    path("Submitpr/", submit_pr, name="submit_pr"),
    path("weekly-report/", weekly_report, name="weekly_report"),
    path("forum/add/", add_forum_post, name="add_forum_post"),
    path("forum/", view_forum, name="view_forum"),
    path("forum/vote/", vote_forum_post, name="vote_forum_post"),
    path("forum/set-vote-status/", set_vote_status, name="set_vote_status"),
    path("forum/comment/", add_forum_comment, name="add_forum_comment"),
    re_path(
        r"^trademarks/query=(?P<slug>[\w\s\W]+)$",
        trademark_detailview,
        name="trademark_detailview",
    ),
    path(
        "update_bch_address/",
        update_bch_address,
        name="update_bch_address",
    ),
    # path(
    #     "api/chatbot/conversation/", chatbot_conversation, name="chatbot_conversation"
    # ),
    path("blt-tomato/", blt_tomato, name="blt-tomato"),
    path(
        "api/v1/projects/",
        ProjectViewSet.as_view({"get": "list", "post": "create", "patch": "update"}),
        name="projects_api",
    ),
    path(
        "auth/delete",
        AuthApiViewset.as_view({"delete": "delete"}),
        name="auth-delete-api",
    ),
    path(
        "api/v1/tags",
        TagApiViewset.as_view({"get": "list", "post": "create"}),
        name="tags-api",
    ),
    path("sizzle/", sizzle, name="sizzle"),
    path("check-in/", checkIN, name="checkIN"),
    path("add-sizzle-checkin/", add_sizzle_checkIN, name="add_sizzle_checkin"),
    path("check-in/<int:report_id>/", checkIN_detail, name="checkIN_detail"),
    path("sizzle-docs/", sizzle_docs, name="sizzle-docs"),
    path("api/timelogsreport/", TimeLogListAPIView, name="timelogsreport"),
    path("time-logs/", TimeLogListView, name="time_logs"),
    path("sizzle-daily-log/", sizzle_daily_log, name="sizzle_daily_log"),
    path(
        "user-sizzle-report/<str:username>/",
        user_sizzle_report,
        name="user_sizzle_report",
    ),
    path("submit-roadmap-pr/", submit_roadmap_pr, name="submit-roadmap-pr"),
    path("view-pr-analysis/", view_pr_analysis, name="view_pr_analysis"),
    path("delete_time_entry/", delete_time_entry, name="delete_time_entry"),
    path("assign-badge/<str:username>/", assign_badge, name="assign_badge"),
    path("github-webhook/", github_webhook, name="github-webhook"),
    # blog urls
    path("blog/", PostListView.as_view(), name="post_list"),
    path("blog/new/", PostCreateView.as_view(), name="post_form"),
    path("blog/<slug:slug>/", PostDetailView.as_view(), name="post_detail"),
    path("blog/<slug:slug>/edit/", PostUpdateView.as_view(), name="post_update"),
    path("blog/<slug:slug>/delete/", PostDeleteView.as_view(), name="post_delete"),
    # gamification related urls
    path("teams/overview/", TeamOverview.as_view(), name="team_overview"),
    path("teams/search-users/", search_users, name="search_users"),
    path("teams/create-team/", create_team, name="create_team"),
    path("teams/join-requests/", join_requests, name="join_requests"),
    path("teams/add-member/", add_member, name="add_member"),
    path("teams/delete-team/", delete_team, name="delete_team"),
    path("teams/leave-team/", leave_team, name="leave_team"),
    path("teams/kick-member/", kick_member, name="kick_member"),
    path("teams/give-kudos/", GiveKudosView.as_view(), name="give_kudos"),
    path(
        "similarity_scan/",
        TemplateView.as_view(template_name="similarity_scan.html"),
        name="similarity_scan",
    ),
    path("projects/create/", create_project, name="create_project"),
    path("teams/challenges/", TeamChallenges.as_view(), name="team_challenges"),
    path("teams/leaderboard/", TeamLeaderboard.as_view(), name="team_leaderboard"),
    path("user_challenges/", UserChallengeListView.as_view(), name="user_challenges"),
    path("project/<slug:slug>/", ProjectsDetailView.as_view(), name="project_detail"),
    path("slack/events", slack_events, name="slack_events"),
    path("owasp/", TemplateView.as_view(template_name="owasp.html"), name="owasp"),
    path("discussion-rooms/", RoomsListView.as_view(), name="rooms_list"),
    path("discussion-rooms/create/", RoomCreateView.as_view(), name="room_create"),
    path("discussion-rooms/join-room/<int:room_id>/", join_room, name="join_room"),
    path("discussion-rooms/delete-room/<int:room_id>/", delete_room, name="delete_room"),
    path("video_call/", video_call, name="video_call"),
    path(
        "batch-send-bacon-tokens/",
        batch_send_bacon_tokens_view,
        name="batch_send_bacon_tokens",
    ),
    path("pending-transactions/", pending_transactions_view, name="pending_transactions"),
    path("open-source-sorting-hat/", ossh_home, name="ossh_home"),
    path("open-source-sorting-hat/results", ossh_results, name="ossh_results"),
    path("get-github-data/", get_github_data, name="get_github_data"),
    path("get-recommended-repos/", get_recommended_repos, name="get_recommended_repos"),
    path("get-recommended-communities/", get_recommended_communities, name="get_recommended_communities"),
    path(
        "get-recommended-discussion-channels/",
        get_recommended_discussion_channels,
        name="get_recommended_discussion_channels",
    ),
    path("get-recommended-articles/", get_recommended_articles, name="get_recommended_articles"),
    path("stats-dashboard/", stats_dashboard, name="stats_dashboard"),
    path("stats/sync-github-projects/", sync_github_projects, name="sync_github_projects"),
    path("stats/run-command/", run_management_command, name="run_management_command"),
    path("test-sentry/", test_sentry, name="test_sentry"),
    path("template_list/", template_list, name="template_list"),
    path(
        "github-issue-prompt/",
        TemplateView.as_view(template_name="github_issue_prompt.html"),
        name="github_issue_prompt",
    ),
    path("check_owasp_compliance/", check_owasp_compliance, name="check_owasp_compliance"),
    path("create-github-issue/", GithubIssueView.as_view(), name="create_github_issue"),
    path("get-github-issue/", get_github_issue, name="get_github_issue"),
    # path("api/v1/owasp-compliance/", views.OwaspComplianceChecker.as_view(), name="owasp-compliance-check"),
    path("repo_list/", RepoListView.as_view(), name="repo_list"),
    path("add_repo", add_repo, name="add_repo"),
    path("organization/<slug:slug>/", OrganizationDetailView.as_view(), name="organization_detail"),
    path("organization/<slug:slug>/update-repos/", update_organization_repos, name="update_organization_repos"),
    # GitHub Issues
    path("github-issues/<int:pk>/", GitHubIssueDetailView.as_view(), name="github_issue_detail"),
    path("github-issues/", GitHubIssuesView.as_view(), name="github_issues"),
    path("api/bacon/submit/", BaconSubmissionView.as_view(), name="bacon_submit"),
    path("bacon-requests/", bacon_requests_view, name="bacon_requests"),
    path("update-submission-status/<int:submission_id>/", update_submission_status, name="update_submission_status"),
    path("initiate-transaction/", initiate_transaction, name="initiate_transaction"),
    path("api/get-wallet-balance/", get_wallet_balance, name="get_wallet_balance"),
    path("extension/", TemplateView.as_view(template_name="extension.html"), name="extension"),
    path("roadmap/", RoadmapView.as_view(), name="roadmap"),
    # Hackathon URLs
    path(
        "hackathons/",
        include(
            [
                path("", HackathonListView.as_view(), name="hackathons"),
                path("create/", HackathonCreateView.as_view(), name="hackathon_create"),
                path("<slug:slug>/", HackathonDetailView.as_view(), name="hackathon_detail"),
                path("<slug:slug>/edit/", HackathonUpdateView.as_view(), name="hackathon_update"),
                path("<slug:slug>/add-sponsor/", HackathonSponsorCreateView.as_view(), name="hackathon_sponsor_create"),
                path("<slug:slug>/add-prize/", HackathonPrizeCreateView.as_view(), name="hackathon_prize_create"),
                # Add the new URL pattern for refreshing repository data
                path(
                    "<slug:hackathon_slug>/refresh-repo/<int:repo_id>/",
                    refresh_repository_data,
                    name="refresh_repository_data",
                ),
            ]
        ),
    ),
    path("page-vote/", page_vote, name="page_vote"),
    # Queue Management URLs
    path("queue/", queue_list, name="queue_list"),
    path("queue/create/", queue_list, name="queue_create"),
    path("queue/<int:queue_id>/edit/", queue_list, name="queue_edit"),
    path("queue/<int:queue_id>/delete/", queue_list, name="queue_delete"),
    path("queue/<int:queue_id>/launch/", queue_list, name="queue_launch"),
    path("queue/<int:queue_id>/update-txid/", update_txid, name="queue_update_txid"),
    path("queue/launch-control/", queue_list, name="queue_launch_page"),
    # Chat room API endpoints
    path("api/send-message/", send_message_api, name="send_message_api"),
    path("api/room-messages/<int:room_id>/", room_messages_api, name="room_messages_api"),
    # direct messaging
    path("messaging/", messaging_home, name="messaging"),
    path("messaging/start-thread/<int:user_id>/", start_thread, name="start_thread"),
    path("api/messaging/<int:thread_id>/messages/", view_thread, name="thread_messages"),
    path("api/messaging/set-public-key/", set_public_key, name="set_public_key"),
    path("api/messaging/<int:thread_id>/get-public-key/", get_public_key, name="get_public_key"),
    path("repository/<slug:slug>/activity-data/", repo_activity_data, name="repo_activity_data"),
    path("api/messaging/thread/<int:thread_id>/delete/", delete_thread, name="delete_thread"),
    path("style-guide/", StyleGuideView.as_view(), name="style_guide"),
    path("reminder-settings/", reminder_settings, name="reminder_settings"),
    path("send-test-reminder/", send_test_reminder, name="send_test_reminder"),
    path("check_domain_security_txt/", check_domain_security_txt, name="check_domain_security_txt"),
]
```

File: blt/settings.py
Lines: 505–533
```python
SOCIALACCOUNT_PROVIDERS = {
    "github": {
        "SCOPE": ["user", "repo"],
        "AUTH_PARAMS": {"access_type": "online"},
    },
    "google": {
        "SCOPE": ["profile", "email"],
        "AUTH_PARAMS": {"access_type": "online"},
    },
    "facebook": {
        "METHOD": "oauth2",
        "SCOPE": ["email"],
        "FIELDS": [
            "id",
            "email",
            "name",
            "first_name",
            "last_name",
            "verified",
            "locale",
            "timezone",
            "link",
        ],
        "EXCHANGE_TOKEN": True,
        "LOCALE_FUNC": lambda request: "en_US",
        "VERIFIED_EMAIL": False,
        "VERSION": "v7.0",
    },
}
```

File: website/views/core.py
Lines: 734–739
```python
# @api_view(["POST"])
# def chatbot_conversation(request):
#     try:
#         today = datetime.now(timezone.utc).date()
#         rate_limit_key = f"global_daily_requests_{today}"
#         request_count = cache.get(rate_limit_key, 0)
```

**Instructions:**

1. **Introduction:**
   - Start with a brief acknowledgment of the contribution. Mention the title and summarize the purpose of the pull request.

2. **Code Quality:**
   - Evaluate the code quality based on readability, maintainability, and adherence to best practices. Provide specific examples from the diff.

3. **Functionality:**
   - Assess the functionality of the changes made. Discuss whether the code achieves its intended purpose and if it introduces any issues.

4. **Testing:**
   - If required, comment on the presence and quality of tests related to the changes.

5. **Documentation:**
   - Review the documentation provided with the pull request. Ensure that it is clear, concise, and adequately covers the changes made.

6. **Suggestions for Improvement:**
   - Provide constructive feedback for any identified issues, including suggestions for refactoring, optimization, or additional features.

7. **Conclusion:**
   - End with a positive note, encouraging the author and expressing willingness to assist further if needed. 

**Output Format:**
```
# Pull Request Review Comment

## Acknowledgment
[Your acknowledgment here]

## Code Quality
[Your evaluation of the code quality]

## Functionality
[Your assessment of the functionality]

## Testing
[Your comments on testing]

## Documentation
[Your review of documentation]

## Suggestions for Improvement
[Your constructive feedback]

## Conclusion
[Your positive closing statement]
```

Ensure your review is clear, concise, and free of jargon that may be confusing to the author, while still being technically accurate.